library(MASS)
library(reshape)
library(mvtnorm)
library(gsl)
library(gdata)
library(graphics)
library(fields)
library(dichromat)
install.packages("reshape")
library(reshape)
install.packages("fields")
install.packages("dichromat")
library(MASS)
library(reshape)
library(mvtnorm)
library(gsl)
library(gdata)
library(graphics)
library(fields)
library(dichromat)
rm(list = ls())
source("load.R")
#------------------------------------------------------------------------------#
# Run simulation to generate figure 1: three performance measures across range
#	of asynchrony and variation in productivity
#------------------------------------------------------------------------------#
# define characteristics of simulation and create array to store outputs
pops <- 12 # of populations (MUST BE EVEN)
max.a <- 11 # maximum productivity
min.a <- 2 # minimum productivity
steps <- 10 # of steps between high and low heterogenity
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)
min_cor <- -0.1 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas
rho.all <- array(NA,dim=c(steps,1))
rho.range <- seq(min_cor,0.99,length.out=steps)
for(ww in 1:length(rho.range)){ # range of covariation among populaitons
rho.all[ww,] <- rho.range[ww]
}
ny = 50
num.sims <- 20
phi <- 0.8
episd <- 0.6
Preturn <- c(0,0,1,0)
for.error <- 0.27
OU <- 0
outcomes <- array(NA,dim=c(num.sims,7))
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))
# run simulations
for(ii in 1:steps){
for(jj in 1:steps){
# biological characteristics
alpha<- inputs$alphas[ii,]
beta<- inputs$betas[ii,]
Ro <- log(alpha)/beta; sum(Ro)
rho <- rho.all[jj,]
control <- 0 #1 is perfect and 0 is none
MSY.add <- 1
source("MSY_hcr_function.R")
for (l in 1: num.sims){
out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)
outcomes[l,] <- out$PMs
}
mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)
}
}
source("load.R")
source("load.R")
source("load.R")
install.packages("mvtnorm")
source("load.R")
install.packages("gsl")
source("load.R")
install.packages("gdata")
source("load.R")
#------------------------------------------------------------------------------#
# Run simulation to generate figure 1: three performance measures across range
#	of asynchrony and variation in productivity
#------------------------------------------------------------------------------#
# define characteristics of simulation and create array to store outputs
pops <- 12 # of populations (MUST BE EVEN)
max.a <- 11 # maximum productivity
min.a <- 2 # minimum productivity
steps <- 10 # of steps between high and low heterogenity
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)
min_cor <- -0.1 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas
rho.all <- array(NA,dim=c(steps,1))
rho.range <- seq(min_cor,0.99,length.out=steps)
for(ww in 1:length(rho.range)){ # range of covariation among populaitons
rho.all[ww,] <- rho.range[ww]
}
ny = 50
num.sims <- 20
phi <- 0.8
episd <- 0.6
Preturn <- c(0,0,1,0)
for.error <- 0.27
OU <- 0
outcomes <- array(NA,dim=c(num.sims,7))
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))
# run simulations
for(ii in 1:steps){
for(jj in 1:steps){
# biological characteristics
alpha<- inputs$alphas[ii,]
beta<- inputs$betas[ii,]
Ro <- log(alpha)/beta; sum(Ro)
rho <- rho.all[jj,]
control <- 0 #1 is perfect and 0 is none
MSY.add <- 1
source("MSY_hcr_function.R")
for (l in 1: num.sims){
out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)
outcomes[l,] <- out$PMs
}
mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)
}
}
dev.new(width=6, height=5,new=FALSE)
par(mfrow=c(2,2),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots
#long.data <- as.data.frame(as.table(mean_out[,,2]/1000))
long.data <- as.data.frame(as.table((mean_out[,,2]/max(mean_out[,,2]))*100))
x <- as.numeric(paste(long.data[,1]))+0.00000001
y <- as.numeric(paste(long.data[,2]))+0.00000001
z <-as.numeric(long.data[,3])
data.loess.decline.10 = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
zz<-as.matrix(predict(data.loess.decline.10, newdata = grid))
xx<-seq(0,1,length.out=100)
yy<-seq(min_cor,1,length.out=100)
image(xx,yy,zz,axes=F,ylab="",xlab="")
axis(2,las=2,cex.axis=0.9)
axis(1,cex.axis=0.9)
mtext("(a) Yield (% max. harvest)",3,cex=1,line=0.5)
mtext("Synchrony",2,line=3.5,adj=-1.5,cex=1.1)
image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3)
long.data <- as.data.frame(as.table(1/mean_out[,,6]))
x <- as.numeric(paste(long.data[,1]))+0.00000001
y <- as.numeric(paste(long.data[,2]))+0.00000001
z <-as.numeric(long.data[,3])
data.loess.decline.10 = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
zz<-as.matrix(predict(data.loess.decline.10, newdata = grid))
xx<-seq(0,1,length.out=100)
yy<-seq(min_cor,1,length.out=100)
image(xx,yy,zz,axes=F,ylab="",xlab="")
axis(2,las=2,cex.axis=0.9)
axis(1,cex.axis=0.9)
mtext("(b) Stability (1/CV)",3,cex=1,line=0.5)
image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3)
long.data <- as.data.frame(as.table(mean_out[,,5]*100))
x <- as.numeric(paste(long.data[,1]))+0.00000001
y <- as.numeric(paste(long.data[,2]))+0.00000001
z <-as.numeric(long.data[,3])
data.loess.decline.10 = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
zz<-as.matrix(predict(data.loess.decline.10, newdata = grid))
zz[zz<0] <- 0
xx<-seq(0,1,length.out=100)
yy<-seq(min_cor,1,length.out=100)
image(xx,yy,zz,axes=F,ylab="",xlab="")
axis(2,las=2,cex.axis=0.9)
axis(1,cex.axis=0.9)
mtext("(c) Risk (% stocks extirpated)",3,cex=1,line=0.5)
mtext("Among population variaion in productivity",1,line=3,adj=-0.3,cex=1.1)
image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3)
