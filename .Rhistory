Sig <- V %*% R %*% V #variance-covariance matrix
epi = rmvnorm(n=ny, sigma=Sig)
#Build time series of Spawners (S), abundance of returning spawners pre-harvest
# (N), and the component of the residual that is correlated throught time (v)
R = t(matrix(Ro,ns,ny))
S = R * (1-0)
v = R; v[,]=0
R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])
N = array(0,dim=c(ny,4,ns))
Ntot = R; Ntot[,]=0
H = Ntot
S = Ntot
predR = Ntot
N[5:7,1,]=R[5:7-(4),]*Preturn[1]
N[6:7,2,]=R[6:7-(5),]*Preturn[2]
N[7,3,]=R[7-(6),]*Preturn[3]
# Loop through years of simulation	Â Â 
for(i in (7+1):ny){
N[i,1,]=R[i-(4),]*Preturn[1]
N[i,2,]=R[i-(5),]*Preturn[2]
N[i,3,]=R[i-(6),]*Preturn[3]
N[i,4,]=R[i-(7),]*Preturn[4]
#N[N[,,]=='NaN'] <- 0
Ntot[i,]=colSums(N[i,,])
#Ntot[i,]=Ntot[i,]*rlnorm(1,0,for.error)
for (yy in 1:length(alpha)){
u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control +
master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)
outcome_error <- (1+rnorm(1,0,OU))
H[i,yy] =  Ntot[i,yy] * u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add
}
S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0
S[i,] = S_exp
S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction
R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])
predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])
v[i,] = log(R[i,])-log(predR[i,])
v[i,is.nan(v[i,])]<-0
}
#Output
S[S[,]=='NaN'] <- 0
Ntot[Ntot[,]=='NaN'] <- 0
pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest
over<- matrix(NA,length(alpha))
ext<- matrix(NA,length(alpha))
harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]
for(j in 1:length(alpha)){
over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]
ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance
}
harvest <-rowSums(H[,])
pms[,1] <- sum(S[20:ny,])/(ny-19)
pms[,2] <- mean(harvest[(ny-20):ny])
pms[,3] <- mean(harvest_rate)
pms[,4] <- sum(over)/length(alpha)
pms[,5] <- sum(ext)/length(alpha)
pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny])
pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny])
list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)
}
#------------------------------------------------------------------------------#
# Function to generate matrix of alphas and betas
#------------------------------------------------------------------------------#
# pops <- # of populations (MUST BE EVEN)
# max.a <- maximum productivity
# min.a <- minimum productivity
# steps <- # of steps between high and low heterogenity
# equ_spw <- equilibrium abundance (assumes all pops are the same size)
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")
# fixed_size <- Should total size remain the same regardless of richness? ("Yes" or "No") if yes then it is equal to equ_spw
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop,fixed_size){
if(fixed_size == "Yes"){equ_spw = equ_spw/pops}
alpha.all <- array(NA,dim=c(steps,pops))
alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))
alpha.all[steps,1] <- min.a
alpha.all[steps, pops] <- max.a
for(i in 2:pops){
alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)
for(ii in 2:(steps)){
alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)
alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)
}
}
if(var_pop == "Yes"){
alpha.all[,1:(pops/3)] <- alpha.all[,1]
alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]
alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]
}
beta.all <- array(NA,dim=c(steps,pops))
beta.all <- log(alpha.all)/equ_spw
list(alphas = alpha.all,betas = beta.all)
}
#------------------------------------------------------------------------------#
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris
#------------------------------------------------------------------------------#
filled.contour3 <-
function (x = seq(0, 1, length.out = nrow(z)),
y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE),
ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE),
levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors,
col = color.palette(length(levels) - 1), plot.title, plot.axes,
key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1,
axes = TRUE, frame.plot = axes,mar, ...)
{
# modification by Ian Taylor of the filled.contour function
# to remove the key and facilitate overplotting with contour()
# further modified by Carey McGilliard and Bridget Ferris
# to allow multiple plots on one page
if (missing(z)) {
if (!missing(x)) {
if (is.list(x)) {
z <- x$z
y <- x$y
x <- x$x
}
else {
z <- x
x <- seq.int(0, 1, length.out = nrow(z))
}
}
else stop("no 'z' matrix specified")
}
else if (is.list(x)) {
y <- x$y
x <- x$x
}
if (any(diff(x) <= 0) || any(diff(y) <= 0))
stop("increasing 'x' and 'y' values expected")
# mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
# on.exit(par(par.orig))
# w <- (3 + mar.orig[2]) * par("csi") * 2.54
# par(las = las)
# mar <- mar.orig
plot.new()
# par(mar=mar)
plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)
if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1)
stop("no proper 'z' matrix specified")
if (!is.double(z))
storage.mode(z) <- "double"
.filled.contour(as.double(x), as.double(y), z, as.double(levels),
col = col)
if (missing(plot.axes)) {
if (axes) {
title(main = "", xlab = "", ylab = "")
Axis(x, side = 1)
Axis(y, side = 2)
}
}
else plot.axes
if (frame.plot)
box()
if (missing(plot.title))
title(...)
else plot.title
invisible()
}
filled.legend <-
function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1,
length.out = ncol(z)), z, xlim = range(x, finite = TRUE),
ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE),
levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors,
col = color.palette(length(levels) - 1), plot.title, plot.axes,
key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1,
axes = TRUE, frame.plot = axes, ...)
{
# modification of filled.contour by Carey McGilliard and Bridget Ferris
# designed to just plot the legend
if (missing(z)) {
if (!missing(x)) {
if (is.list(x)) {
z <- x$z
y <- x$y
x <- x$x
}
else {
z <- x
x <- seq.int(0, 1, length.out = nrow(z))
}
}
else stop("no 'z' matrix specified")
}
else if (is.list(x)) {
y <- x$y
x <- x$x
}
if (any(diff(x) <= 0) || any(diff(y) <= 0))
stop("increasing 'x' and 'y' values expected")
#  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar
#  on.exit(par(par.orig))
#  w <- (3 + mar.orig[2L]) * par("csi") * 2.54
#layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))
#  par(las = las)
#  mar <- mar.orig
#  mar[4L] <- mar[2L]
#  mar[2L] <- 1
#  par(mar = mar)
# plot.new()
plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i",
yaxs = "i")
rect(0, levels[-length(levels)], 1, levels[-1L], col = col)
if (missing(key.axes)) {
if (axes)
axis(4)
}
else key.axes
box()
}
risk_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx, row){
if(row == 1){ylim = 25}
if(row == 2){ylim = 10}
if(row == 3){ylim = 10}
sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)
x <- as.numeric(paste(sims_out[,1]))
y <- as.numeric(paste(sims_out[,2]))
z <-as.numeric(sims_out[,3]*100)
data.loess= loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
ext<-as.matrix(predict(data.loess, newdata = grid))
x <- as.numeric(paste(sims_out[,1]))+0.00000001
y <- as.numeric(paste(sims_out[,2]))+0.00000001
z <-as.numeric(1/sims_out[,4])
data.loess = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
stability<-as.matrix(predict(data.loess, newdata = grid))
ext[ext<0]<-0
plot(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3,ylim=c(0, ylim),xlim=c(0.75,2.75),yaxt="n",xaxt="n",ylab="",xlab="")
sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)
x <- as.numeric(paste(sims_out[,1]))
y <- as.numeric(paste(sims_out[,2]))
z <-as.numeric(sims_out[,3]*100)
data.loess= loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
ext<-as.matrix(predict(data.loess, newdata = grid))
x <- as.numeric(paste(sims_out[,1]))+0.00000001
y <- as.numeric(paste(sims_out[,2]))+0.00000001
z <-as.numeric(1/sims_out[,4])
data.loess = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
stability<-as.matrix(predict(data.loess, newdata = grid))
ext[ext<0]<-0
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)
sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)
x <- as.numeric(paste(sims_out[,1]))
y <- as.numeric(paste(sims_out[,2]))
z <-as.numeric(sims_out[,3]*100)
data.loess= loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
ext<-as.matrix(predict(data.loess, newdata = grid))
x <- as.numeric(paste(sims_out[,1]))+0.00000001
y <- as.numeric(paste(sims_out[,2]))+0.00000001
z <-as.numeric(1/sims_out[,4])
data.loess = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
stability<-as.matrix(predict(data.loess, newdata = grid))
ext[ext<0]<-0
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)
sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)
x <- as.numeric(paste(sims_out[,1]))
y <- as.numeric(paste(sims_out[,2]))
z <-as.numeric(sims_out[,3]*100)
data.loess= loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
ext<-as.matrix(predict(data.loess, newdata = grid))
x <- as.numeric(paste(sims_out[,1]))+0.00000001
y <- as.numeric(paste(sims_out[,2]))+0.00000001
z <-as.numeric(1/sims_out[,4])
data.loess = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
stability<-as.matrix(predict(data.loess, newdata = grid))
ext[ext<0]<-0
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)
if(yaxis_plot=="TRUE"){
axis(2,las=2)
}else{
axis(2,las=2,labels = F)
}
if(xaxis_plot=="TRUE"){
axis(1)
}else{
axis(1,labels = F)
}
if(incl.legend == "TRUE"){
legend(1.5,9,c("0","0.125","0.25","0.5"),lwd=3,lty=1,col=c(colors[4],colors[3],colors[2],colors[1]),cex=0.9, bty="n")
text(2,9,"Mgmt. control (C*)",cex=0.9)
}
}
yield_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx, row){
if(row == 1){ylim = 100}
if(row == 2){ylim = 100}
if(row == 3){ylim = 100}
long_sims <- round(long_sims, digits = 2)
long_sims$max.yld <- long_sims$harvest/max(long_sims$harvest)
sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)
x <- as.numeric(paste(sims_out[,1]))
y <- as.numeric(paste(sims_out[,2]))
z <-as.numeric(sims_out[,8]*100)
data.loess= loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
ext<-as.matrix(predict(data.loess, newdata = grid))
x <- as.numeric(paste(sims_out[,1]))+0.00000001
y <- as.numeric(paste(sims_out[,2]))+0.00000001
z <-as.numeric(1/sims_out[,4])
data.loess = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
stability<-as.matrix(predict(data.loess, newdata = grid))
ext[ext<0]<-0
plot(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3,ylim=c(0, ylim),xlim=c(0.75,2.75),yaxt="n",xaxt="n",ylab="",xlab="")
sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)
x <- as.numeric(paste(sims_out[,1]))
y <- as.numeric(paste(sims_out[,2]))
z <-as.numeric(sims_out[,8]*100)
data.loess= loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
ext<-as.matrix(predict(data.loess, newdata = grid))
x <- as.numeric(paste(sims_out[,1]))+0.00000001
y <- as.numeric(paste(sims_out[,2]))+0.00000001
z <-as.numeric(1/sims_out[,4])
data.loess = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
stability<-as.matrix(predict(data.loess, newdata = grid))
ext[ext<0]<-0
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)
sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)
x <- as.numeric(paste(sims_out[,1]))
y <- as.numeric(paste(sims_out[,2]))
z <-as.numeric(sims_out[,8]*100)
data.loess= loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
ext<-as.matrix(predict(data.loess, newdata = grid))
x <- as.numeric(paste(sims_out[,1]))+0.00000001
y <- as.numeric(paste(sims_out[,2]))+0.00000001
z <-as.numeric(1/sims_out[,4])
data.loess = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
stability<-as.matrix(predict(data.loess, newdata = grid))
ext[ext<0]<-0
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)
sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)
x <- as.numeric(paste(sims_out[,1]))
y <- as.numeric(paste(sims_out[,2]))
z <-as.numeric(sims_out[,8]*100)
data.loess= loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
ext<-as.matrix(predict(data.loess, newdata = grid))
x <- as.numeric(paste(sims_out[,1]))+0.00000001
y <- as.numeric(paste(sims_out[,2]))+0.00000001
z <-as.numeric(1/sims_out[,4])
data.loess = loess(z~x*y)
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))
stability<-as.matrix(predict(data.loess, newdata = grid))
ext[ext<0]<-0
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)
if(yaxis_plot=="TRUE"){
axis(2,las=2)
}else{
axis(2,las=2,labels = F)
}
if(xaxis_plot=="TRUE"){
axis(1)
}else{
axis(1,labels = F)
}
if(incl.legend == "TRUE"){
legend(1.5,95,c("0","0.125","0.25","0.5"),lwd=3,lty=1,col=c(colors[4],colors[3],colors[2],colors[1]),cex=0.9, bty="n")
text(2,95,"Mgmt. control (C*)",cex=0.9)
}
}
########################################################################################
# FigS3_riskXstabMultiPanell.R
#
# Figure S3: Influence of management control, biodiversity and risk tolerance
#   on risk - stability tradeoffs
#
# Last updated: July 5, 2019
# Author: B. Connors (DFO)
#
########################################################################################
# --- Load simulation output -----------------------------------------------------------
risk_sims <-readRDS(file = "output/mgmt_risk_sims.100.phi_0.8.Rho_0.6.logFE_0.1.OU_0.12July2019")
long_sims <- round(risk_sims , digits = 2)
min_cor = 0
colors <- viridis(4)
# --- Generate figure ----------------------------------------------------------------
jpeg("figures/fig_S3.phi_0.8.Rho_0.6.logFE_0.1.OU_0.11July2019.jpeg",width=8, height=7, units="in",res=800)
#dev.new(width=8, height=10,new=FALSE)
# Set up plotting region
m <- rbind(
cbind(0.05,0.35,0.7,1),
cbind(0.35,0.65,0.7,1),
cbind(0.65,0.95,0.7,1),
cbind(0.05,0.35,0.4,0.7),
cbind(0.35,0.65,0.4,0.7),
cbind(0.65,0.95,0.4,0.7),
cbind(0.05,0.35,0.1,0.4),
cbind(0.35,0.65,0.1,0.4),
cbind(0.65,0.95,0.1,0.4),
cbind(0,1,0,1)
)
split.screen(m)
screen(1)
par(mar = c(1,1.5,1,1))
risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 1, 20, 1)
mtext("Var. in productivity = low",3,line=0, cex=0.9)
screen(2)
par(mar = c(1,1.5,1,1))
risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)
mtext("Var. in productivity = medium",3,line=0, cex=0.9)
screen(3)
par(mar = c(1,1.5,1,1))
risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)
mtext("Var. in productivity = high",3,line=0, cex=0.9)
mtext("OF tolerance = high",4,line=0.5)
screen(4)
par(mar = c(1,1.5,1,1))
risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 0.75, 20, 2)
mtext("Risk (% stocks extirpated)",2,line=2)
screen(5)
par(mar = c(1,1.5,1,1))
risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)
screen(6)
par(mar = c(1,1.5,1,1))
risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)
mtext("OF tolerance = medium",4,line=0.5)
screen(7)
par(mar = c(1,1.5,1,1))
risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)
screen(8)
par(mar = c(1,1.5,1,1))
risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)
mtext("Catch stability (1/CV)",1,line=2.5)
screen(9)
par(mar = c(1,1.5,1,1))
risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)
mtext("OF tolerance = low",4,line=0.5)
close.screen(all.screens = TRUE)
dev.off()
########################################################################################
# Fig1_syncXrich.R
#
# Figure 1: Fishery and conservation consequences of stock diversity
# Last updated: July 5, 2019
# Author: B. Connors (DFO)
#
########################################################################################
# --- Load simulation output -----------------------------------------------------------
mean_out <-readRDS(file = "output/richness_sync_100_0.8_0.6_0010_0.1_0_heteroP5.11July2019")
max.catch_hetP_2 <- c(max(mean_out[1,,2]),max(mean_out[2,,2]),max(mean_out[3,,2]),max(mean_out[4,,2]),max(mean_out[5,,2]),max(mean_out[6,,2]),max(mean_out[7,,2]),max(mean_out[8,,2]),max(mean_out[9,,2]),max(mean_out[10,,2]))
max.catch <- cbind(max.catch_hetP_2,max.catch_hetP_2,max.catch_hetP_2,max.catch_hetP_2,max.catch_hetP_2,max.catch_hetP_2,max.catch_hetP_2,max.catch_hetP_2,max.catch_hetP_2,max.catch_hetP_2)
min_cor=0
jpeg("figures/fig_1_phi_0.8.Rho_0.6.logFE_0.10.OU_0.hetP5.11July2019.jpeg",width=6, height=5.15, units="in",res=800)
#dev.new(width=6, height=5,new=FALSE)
par(mfrow=c(2,2),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots
long.data <- as.data.frame(as.table((mean_out[,,2]/max.catch)*100))
x <- as.numeric(paste(long.data[,1]))+0.00000001
y <- as.numeric(paste(long.data[,2]))+0.00000001
z <-as.numeric(long.data[,3])
data.loess.decline.10 = loess(z~x*y)
grid = expand.grid(list(x = seq(6,31,length.out=100), y = seq(min_cor,1,length.out=100)))
zz<-as.matrix(predict(data.loess.decline.10, newdata = grid))
xx<-seq(6,31,length.out=100)
yy<-seq(min_cor,1,length.out=100)
image(xx,yy,zz,axes=F,ylab="",xlab="")
axis(2,las=2,cex.axis=0.9)
axis(1,at=c(6,11,16,21,26,31),cex.axis=0.9)
mtext("Yield (% max. harvest)",3,cex=0.9,line=0.5)
mtext("A",3,cex=1.2,line=0.5,adj=-0.25,font=2)
mtext("Synchrony",2,line=2.5)
image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3,col = rev(viridis(100)))
long.data <- as.data.frame(as.table(1/mean_out[,,6]))
x <- as.numeric(paste(long.data[,1]))+0.00000001
y <- as.numeric(paste(long.data[,2]))+0.00000001
z <-as.numeric(long.data[,3])
data.loess.decline.10 = loess(z~x*y)
grid = expand.grid(list(x = seq(6,31,length.out=100), y = seq(min_cor,1,length.out=100)))
zz<-as.matrix(predict(data.loess.decline.10, newdata = grid))
xx<-seq(6,31,length.out=100)
yy<-seq(min_cor,1,length.out=100)
image(xx,yy,zz,axes=F,ylab="",xlab="")
axis(2,las=2,cex.axis=0.9)
axis(1,at=c(6,11,16,21,26,31),cex.axis=0.9)
mtext("Stability (1/CV)",3,cex=0.9,line=0.5)
mtext("B",3,cex=1.2,line=0.5,adj=-0.25,font=2)
image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3,col = rev(viridis(100)))
long.data <- as.data.frame(as.table(mean_out[,,5]*100))
x <- as.numeric(paste(long.data[,1]))+0.00000001
y <- as.numeric(paste(long.data[,2]))+0.00000001
z <-as.numeric(long.data[,3])
data.loess.decline.10 = loess(z~x*y)
grid = expand.grid(list(x = seq(6,31,length.out=100), y = seq(min_cor,1,length.out=100)))
zz<-as.matrix(predict(data.loess.decline.10, newdata = grid))
zz[zz<0] <- 0
xx<-seq(6,31,length.out=100)
yy<-seq(min_cor,1,length.out=100)
image(xx,yy,zz,axes=F,ylab="",xlab="")
axis(2,las=2,cex.axis=0.9)
axis(1,at=c(6,11,16,21,26,31),cex.axis=0.9)
mtext("  Risk (% stocks extirpated)",3,cex=0.9,line=0.5)
mtext("C",3,cex=1.2,line=0.5,adj=-0.25,font=2)
mtext("Richness (no. stocks)",1,line=-0.8,outer=T)
mtext("Synchrony",2,line=2.5)
image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3,col = viridis(100))
dev.off()
inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes","Yes")
# define characteristics of population complex
pops <- 12 # of populations (MUST BE EVEN)
max.a <- 7 # maximum productivity
min.a <- 2 # minimum productivity
steps <- 10 # of steps between high and low heterogenity
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No","Yes") # generate matrix of alphas and betas
inputs
