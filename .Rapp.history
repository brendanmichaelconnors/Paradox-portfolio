alpha
process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)
ext
ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V #cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		#N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
#
		for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * (u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add) 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])
ext
over
S
exp(2.3)
exp(2)
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 8 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas
inputs
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas
inputs
rm(list = ls())#
#
source("load.R")
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
#
ny = 50#
num.sims <- 20#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.0#
OU <- 0.0#
#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- sims_out#
#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#############################################
#
# no control, 0.75 harvest#
control <- 0 #
MSY.add <- 0.75#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# perfect control, 0.5 harvest#
control <- 0 #
MSY.add <- 0.5#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.125 harvest#
control <- 0 #
MSY.add <- 0.125#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.27.OU_0.Dec242018")
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)
dev.new(width=4, height=4,new=FALSE)#
par(mfrow=c(1,1),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,45),xlim=c(0.8,3.5),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2.4,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.9,24,"Mgmt. control (C*)",cex=0.8)
dev.new(width=4, height=4,new=FALSE)#
par(mfrow=c(1,1),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,45),xlim=c(0.8,3.5),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.12)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2.4,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.9,24,"Mgmt. control (C*)",cex=0.8)
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
#
ny = 50#
num.sims <- 50#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.0#
OU <- 0.0#
#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- sims_out#
#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#############################################
#
# no control, 0.75 harvest#
control <- 0 #
MSY.add <- 0.75#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# perfect control, 0.5 harvest#
control <- 0 #
MSY.add <- 0.5#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.125 harvest#
control <- 0 #
MSY.add <- 0.125#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.27.OU_0.Dec242018")
dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,45),xlim=c(0.8,3.5),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2.4,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.9,24,"Mgmt. control (C*)",cex=0.8)
dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2.4,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.9,24,"Mgmt. control (C*)",cex=0.8)
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,45),xlim=c(0.8,3.5),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2.4,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.9,24,"Risk tolerance (P*)",cex=0.8)
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2.4,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.9,24,"Risk tolerance (P*)",cex=0.8)
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")
dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.9,24,"Mgmt. control (C*)",cex=0.8)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.9,24,"Risk tolerance (P*)",cex=0.8)
text(2.5,24,"Mgmt. control (C*)",cex=0.8)
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2__control_risk_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=8, height=4, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
mtext("Stability (1/CV)",1,line=2.5,outer=T)
dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5,outer=T)
mtext("Stability (1/CV)",1,line=1,outer=T)
mtext("B",1,line=1,adj=-0.5,font=2.cex=1.2)
mtext("B",1,line=1,adj=-0.5,font=2,cex=1.2)
mtext("B",1,line=0,adj=-0.5,font=2,cex=1.2)
mtext("B",3,line=0,adj=-0.5,font=2,cex=1.2)
mtext("B",3,line=0,adj=-0.25,font=2,cex=1.2)
mtext("B",3,line=0,adj=-0.15,font=2,cex=1.2)
mtext("B",3,line=0,adj=-0.1,font=2,cex=1.2)
mtext("B",3,line=0,adj=-0.1,font=2,cex=1.3)
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2__control_risk_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=8, height=4, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2__control_risk_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=8, height=4, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2__control_risk_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=8, height=4, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0.25,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0.25,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
master.sims_out
long_sims$max.yld <- long_sims$harvest/max(long_sims$harvest)
long_sims$max.yld
long_sims
dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
long_sims$max.yld <- long_sims$harvest/max(long_sims$harvest)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,100),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")
axis(2,las=2)
dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
long_sims$max.yld <- long_sims$harvest/max(long_sims$harvest)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,100),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")
legend(2,40,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")
text(2.5,44,"Mgmt. control (C*)",cex=0.8)
mtext("A",3,line=0.25,adj=-0.1,font=2,cex=1.3)
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,100),xlim=c(0.8,3.5),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0.25,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)
legend(2,44,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,44,"Risk tolerance (P*)",cex=0.8)
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2_control_yield_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=8, height=4, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
long_sims$max.yld <- long_sims$harvest/max(long_sims$harvest)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,100),xlim=c(0.8,3),yaxt="n",ylab="",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Yield (% of maximum)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,40,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,44,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0.25,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,100),xlim=c(0.8,3),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0.25,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,8]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,44,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,44,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2__control_risk_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=6, height=3, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2_control_risk_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=6.5, height=3.25, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.5),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2_control_risk_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=6.5, height=3.25, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2_control_risk_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=6.5, height=3.25, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
mtext("Stability (1/CV)",1,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2_control_risk_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=6.5, height=3.25, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
#
jpeg("figures/fig_2_control_risk_phi_0.8.Rho_0.6.logFE_0.0.OU_0.Dec242018.jpeg",width=6.5, height=3.25, units="in",res=800)#
#dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)#
#
dev.off()
## Load functions and libraries for analysis#
#
source("functions.R") #
#
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)
#------------------------------------------------------------------------------##
# Run simulation to generate figure 4: two performance measures across range #
#	of asynchrony and population richness#
#------------------------------------------------------------------------------##
# define characteristics of simulation and create array to store outputs#
pops <- c(6,9,12,15,18,21,24,27,30,33)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 200#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0 #
OU <- 0 #
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
# run simulations#
for(ii in 1:length(pops)){#
  for(jj in 1:steps){#
    # biological characteristics#
    pop.num <- pops[ii]#
    inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes")#
    alpha<- inputs$alphas[9,]#
    beta<- inputs$betas[9,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]#
    control <- 0 #1 is perfect and 0 is none#
    MSY.add <- 1#
    source("MSY_hcr_function.R")		#
    # run simulations!#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
        mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
saveRDS(mean_out,"richness_sync_200_0.8_0.6_0010_0_0_heteroP9.28Dec2018")    #
###############
# define characteristics of simulation and create array to store outputs#
pops <- c(6,9,12,15,18,21,24,27,30,33)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 200#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0 #
OU <- 0 #
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
# run simulations#
for(ii in 1:length(pops)){#
  for(jj in 1:steps){#
    # biological characteristics#
    pop.num <- pops[ii]#
    inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes")#
    alpha<- inputs$alphas[1,]#
    beta<- inputs$betas[1,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]#
    control <- 0 #1 is perfect and 0 is none#
    MSY.add <- 1#
    source("MSY_hcr_function.R")		#
    # run simulations!#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
saveRDS(mean_out,"richness_sync_200_0.8_0.6_0010_0_0_heteroP1.28Dec2018")    #
###############
# define characteristics of simulation and create array to store outputs#
pops <- c(6,9,12,15,18,21,24,27,30,33)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 200#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0 #
OU <- 0 #
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
# run simulations#
for(ii in 1:length(pops)){#
  for(jj in 1:steps){#
    # biological characteristics#
    pop.num <- pops[ii]#
    inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes")#
    alpha<- inputs$alphas[5,]#
    beta<- inputs$betas[5,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]#
    control <- 0 #1 is perfect and 0 is none#
    MSY.add <- 1#
    source("MSY_hcr_function.R")		#
    # run simulations!#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
saveRDS(mean_out,"richness_sync_200_0.8_0.6_0010_0_0_heteroP5.28Dec2018")
mean_out
MSY.add
control
#------------------------------------------------------------------------------##
# Run simulation to generate figure 4: two performance measures across range #
#	of asynchrony and population richness#
#------------------------------------------------------------------------------##
# define characteristics of simulation and create array to store outputs#
pops <- c(6,9,12,15,18,21,24,27,30,33)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 500#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0 #
OU <- 0 #
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
# run simulations#
for(ii in 1:length(pops)){#
  for(jj in 1:steps){#
    # biological characteristics#
    pop.num <- pops[ii]#
    inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes")#
    alpha<- inputs$alphas[9,]#
    beta<- inputs$betas[9,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]#
    control <- 0 #1 is perfect and 0 is none#
    MSY.add <- 1#
    source("MSY_hcr_function.R")		#
    # run simulations!#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
        mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
saveRDS(mean_out,"richness_sync_200_0.8_0.6_0010_0_0_heteroP9.28Dec2018")    #
###############
# define characteristics of simulation and create array to store outputs#
pops <- c(6,9,12,15,18,21,24,27,30,33)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){#
  rho.all[ww,] <- rho.range[ww]#
}#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
# run simulations#
for(ii in 1:length(pops)){#
  for(jj in 1:steps){#
    # biological characteristics#
    pop.num <- pops[ii]#
    inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes")#
    alpha<- inputs$alphas[1,]#
    beta<- inputs$betas[1,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]#
    control <- 0 #1 is perfect and 0 is none#
    MSY.add <- 1#
    source("MSY_hcr_function.R")		#
    # run simulations!#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
saveRDS(mean_out,"richness_sync_200_0.8_0.6_0010_0_0_heteroP1.28Dec2018")    #
###############
# define characteristics of simulation and create array to store outputs#
pops <- c(6,9,12,15,18,21,24,27,30,33)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){#
  rho.all[ww,] <- rho.range[ww]#
}#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
# run simulations#
for(ii in 1:length(pops)){#
  for(jj in 1:steps){#
    # biological characteristics#
    pop.num <- pops[ii]#
    inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes")#
    alpha<- inputs$alphas[5,]#
    beta<- inputs$betas[5,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]#
    control <- 0 #1 is perfect and 0 is none#
    MSY.add <- 1#
    source("MSY_hcr_function.R")		#
    # run simulations!#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
saveRDS(mean_out,"richness_sync_200_0.8_0.6_0010_0_0_heteroP5.28Dec2018")
## Load functions and libraries for analysis#
source("functions_PC.R") #
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)#
library(ggplot2)#
library(gridExtra)#
library(ggpubr)
source("functions_PC.R")
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.0#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.OU_0.Dec282018")
## Functions for analysis#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add,for.error){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V #cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	Â Â #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
		Ntot[i,]=Ntot[i,]*rlnorm(1,0,for.error)#
			for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}#
risk_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx){#
  sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",xaxt="n",ylab="",xlab="")#
  sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.75 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
  if(yaxis_plot=="TRUE"){#
    axis(2,las=2)  #
  }else{#
    axis(2,las=2,labels = F)  #
  }  #
  if(xaxis_plot=="TRUE"){#
    axis(1)  #
  }else{#
    axis(1,labels = F)  #
  }   #
  if(incl.legend == "TRUE"){#
    legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.7, bty="n")#
    text(2.5,24,"Mgmt. control (C*)",cex=0.7)#
  }#
}
## Load functions and libraries for analysis#
source("functions_PC.R") #
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)#
library(ggplot2)#
library(gridExtra)#
library(ggpubr)
#------------------------------------------------------------------------------##
# Run simulation to generate figure 4: two performance measures across range #
#	of asynchrony and population richness#
#------------------------------------------------------------------------------##
# define characteristics of simulation and create array to store outputs#
pops <- c(6,9,12,15,18,21,24,27,30,33)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 100#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.15 #
OU <- 0 #
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
# run simulations#
for(ii in 1:length(pops)){#
  for(jj in 1:steps){#
    # biological characteristics#
    pop.num <- pops[ii]#
    inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes")#
    alpha<- inputs$alphas[8,]#
    beta<- inputs$betas[8,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]#
    control <- 0 #1 is perfect and 0 is none#
    MSY.add <- 1#
    source("MSY_hcr_function.R")		#
    # run simulations!#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
        mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
saveRDS(mean_out,"richness_sync_200_0.8_0.6_0010_0_0_heteroP8.25Dec2018")    #
###############
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
# run simulations#
for(ii in 1:length(pops)){#
  for(jj in 1:steps){#
    # biological characteristics#
    pop.num <- pops[ii]#
    inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes")#
    alpha<- inputs$alphas[2,]#
    beta<- inputs$betas[2,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]#
    control <- 0 #1 is perfect and 0 is none#
    MSY.add <- 1#
    source("MSY_hcr_function.R")		#
    # run simulations!#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
saveRDS(mean_out,"richness_sync_200_0.8_0.6_0010_0_0_heteroP2.25Dec2018")    #
###############
# define characteristics of simulation and create array to store outputs#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
# run simulations#
for(ii in 1:length(pops)){#
  for(jj in 1:steps){#
    # biological characteristics#
    pop.num <- pops[ii]#
    inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes")#
    alpha<- inputs$alphas[6,]#
    beta<- inputs$betas[6,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]#
    control <- 0 #1 is perfect and 0 is none#
    MSY.add <- 1#
    source("MSY_hcr_function.R")		#
    # run simulations!#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
saveRDS(mean_out,"richness_sync_200_0.8_0.6_0010_0_0_heteroP6.25Dec2018")
## Load functions and libraries for analysis#
source("functions_PC.R") #
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)#
library(ggplot2)#
library(gridExtra)#
library(ggpubr)
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"output/mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Dec282018")
## Load functions and libraries for analysis#
source("functions_PC.R") #
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)#
library(ggplot2)#
library(gridExtra)#
library(ggpubr)
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"output/mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Dec282018")
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Dec282018")
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 100#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Dec282018")
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 200#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Dec282018")
inputs
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"Yes") # generate matrix of alphas and betas
inputs
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 200#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Dec282018")
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.OU_0.Dec282018")
for.error
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.0#
OU <- 0.0#
#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- sims_out#
#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#############################################
#
# no control, 0.75 harvest#
control <- 0 #
MSY.add <- 0.75#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# perfect control, 0.5 harvest#
control <- 0 #
MSY.add <- 0.5#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.125 harvest#
control <- 0 #
MSY.add <- 0.125#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.OU_0.Dec28NEW2018")
## Functions for analysis#
#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
#
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V #cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		#N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
#
		for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * (u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add) 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.0#
OU <- 0.0#
#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- sims_out#
#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#############################################
#
# no control, 0.75 harvest#
control <- 0 #
MSY.add <- 0.75#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# perfect control, 0.5 harvest#
control <- 0 #
MSY.add <- 0.5#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.125 harvest#
control <- 0 #
MSY.add <- 0.125#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.OU_0.Dec28NEW2018")
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)
ev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)
outcome_error
OU
(1+rnorm(1,0,OU))
rlnorm(1,0,for.error)
## Functions for analysis#
#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
#
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V #cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		#N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
#
		for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * (u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add) 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		#v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.0#
OU <- 0.0#
#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- sims_out#
#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#############################################
#
# no control, 0.75 harvest#
control <- 0 #
MSY.add <- 0.75#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# perfect control, 0.5 harvest#
control <- 0 #
MSY.add <- 0.5#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.125 harvest#
control <- 0 #
MSY.add <- 0.125#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.OU_0.Dec28NEW2018")
## Functions for analysis#
#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
#
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V #cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		#N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
#
		for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * (u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add) 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}
## Functions for analysis#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add,for.error){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V#cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
		#Ntot[i,]=Ntot[i,]*rlnorm(1,0,for.error)#
			for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}#
risk_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx){#
  sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",xaxt="n",ylab="",xlab="")#
  sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.75 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
  if(yaxis_plot=="TRUE"){#
    axis(2,las=2)  #
  }else{#
    axis(2,las=2,labels = F)  #
  }  #
  if(xaxis_plot=="TRUE"){#
    axis(1)  #
  }else{#
    axis(1,labels = F)  #
  }   #
  if(incl.legend == "TRUE"){#
    legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.7, bty="n")#
    text(2.5,24,"Mgmt. control (C*)",cex=0.7)#
  }#
}
## Functions for analysis#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V#cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
		#Ntot[i,]=Ntot[i,]*rlnorm(1,0,for.error)#
			for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}#
risk_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx){#
  sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",xaxt="n",ylab="",xlab="")#
  sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.75 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
  if(yaxis_plot=="TRUE"){#
    axis(2,las=2)  #
  }else{#
    axis(2,las=2,labels = F)  #
  }  #
  if(xaxis_plot=="TRUE"){#
    axis(1)  #
  }else{#
    axis(1,labels = F)  #
  }   #
  if(incl.legend == "TRUE"){#
    legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.7, bty="n")#
    text(2.5,24,"Mgmt. control (C*)",cex=0.7)#
  }#
}
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.0#
OU <- 0.0#
#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- sims_out#
#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#############################################
#
# no control, 0.75 harvest#
control <- 0 #
MSY.add <- 0.75#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# perfect control, 0.5 harvest#
control <- 0 #
MSY.add <- 0.5#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.125 harvest#
control <- 0 #
MSY.add <- 0.125#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.OU_0.Dec28NEW2018")
dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas
inputs
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- sims_out#
#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#############################################
#
# no control, 0.75 harvest#
control <- 0 #
MSY.add <- 0.75#
#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# perfect control, 0.5 harvest#
control <- 0 #
MSY.add <- 0.5#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.125 harvest#
control <- 0 #
MSY.add <- 0.125#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
#
master.sims_out <- rbind(master.sims_out,sims_out)#
#
saveRDS(master.sims_out,"mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.OU_0.Dec28NEW2018")
dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)
## Load functions and libraries for analysis#
source("functions_PC.R") #
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)#
library(ggplot2)#
library(gridExtra)#
library(ggpubr)
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 10#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"output/mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Dec282018")
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)
dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)
long_sims <- round(master.sims_out, digits = 2)
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=2.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2.5)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=2.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=2.5)
close.screen(all.screens = TRUE)
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=2.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2.5)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=2.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=2.5)
dev.new(width=8, height=10,new=FALSE)
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=2.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2.5)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=2.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=2.5)#
close.screen(all.screens = TRUE)
close.screen(all.screens = TRUE)
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=2.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2.5)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=2.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=2.5)
## Functions for analysis#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add,for.error){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V#cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		#N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
		#Ntot[i,]=Ntot[i,]*rlnorm(1,0,for.error)#
			for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}#
risk_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx){#
  sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
   ext[ext<0]<-0#
 plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",xaxt="n",ylab="",xlab="")#
  sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.75 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
  if(yaxis_plot=="TRUE"){#
    axis(2,las=2)  #
  }else{#
    axis(2,las=2,labels = F)  #
  }  #
  if(xaxis_plot=="TRUE"){#
    axis(1)  #
  }else{#
    axis(1,labels = F)  #
  }   #
  if(incl.legend == "TRUE"){#
    legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.7, bty="n")#
    text(2.5,24,"Mgmt. control (C*)",cex=0.7)#
  }#
}
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=2.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2.5)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=2.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=2.5)
close.screen(all.screens = TRUE)
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=2.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2.5)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=2.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=2.5)
close.screen(all.screens = TRUE)
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2.5)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=2.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=2.5)#
close.screen(all.screens = TRUE)
close.screen(all.screens = TRUE)
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
## Functions for analysis#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add,for.error){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V#cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		#N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
		#Ntot[i,]=Ntot[i,]*rlnorm(1,0,for.error)#
			for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}#
risk_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx){#
  sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
   ext[ext<0]<-0#
 plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.5,2.5),yaxt="n",xaxt="n",ylab="",xlab="")#
  sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.75 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
  if(yaxis_plot=="TRUE"){#
    axis(2,las=2)  #
  }else{#
    axis(2,las=2,labels = F)  #
  }  #
  if(xaxis_plot=="TRUE"){#
    axis(1)  #
  }else{#
    axis(1,labels = F)  #
  }   #
  if(incl.legend == "TRUE"){#
    legend(1.5,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.7, bty="n")#
    text(2,24,"Mgmt. control (C*)",cex=0.7)#
  }#
}
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=0.5)
## Functions for analysis#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add,for.error){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V#cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		#N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
		#Ntot[i,]=Ntot[i,]*rlnorm(1,0,for.error)#
			for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}#
risk_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx){#
  sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
   ext[ext<0]<-0#
 plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.75,2.75),yaxt="n",xaxt="n",ylab="",xlab="")#
  sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.75 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
  if(yaxis_plot=="TRUE"){#
    axis(2,las=2)  #
  }else{#
    axis(2,las=2,labels = F)  #
  }  #
  if(xaxis_plot=="TRUE"){#
    axis(1)  #
  }else{#
    axis(1,labels = F)  #
  }   #
  if(incl.legend == "TRUE"){#
    legend(1.5,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.7, bty="n")#
    text(2,24,"Mgmt. control (C*)",cex=0.7)#
  }#
}
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=0.5)
close.screen(all.screens = TRUE)
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 100#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"output/mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Dec282018")
long_sims <- round(master.sims_out , digits = 2)
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 50)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 90)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
## Functions for analysis#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add,for.error){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V#cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		#N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
		#Ntot[i,]=Ntot[i,]*rlnorm(1,0,for.error)#
			for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}#
risk_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx, row){#
  if(row == 1){ylim == 25}#
  if(row == 2){ylim == 10}#
  if(row == 3){ylim == 5}#
  sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0, ylim),xlim=c(0.75,2.75),yaxt="n",xaxt="n",ylab="",xlab="")#
  sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.75 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
  if(yaxis_plot=="TRUE"){#
    axis(2,las=2)  #
  }else{#
    axis(2,las=2,labels = F)  #
  }  #
  if(xaxis_plot=="TRUE"){#
    axis(1)  #
  }else{#
    axis(1,labels = F)  #
  }   #
  if(incl.legend == "TRUE"){#
    legend(1.5,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.7, bty="n")#
    text(2,24,"Mgmt. control (C*)",cex=0.7)#
  }#
}
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
master.sims_out
indexx<- 90 # set index (or "slice"); columns are synchrony and rows are heterogenity in productivity#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)
dev.new(width=8, height=4,new=FALSE)#
par(mfrow=c(1,2),bty="o", mar=c(2,2,2,2),oma=c(3,2,0,0))#set dimensions to plots#
#
long_sims <- round(master.sims_out, digits = 2)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="Risk (% extirpated)",xlab="Stability (1/CV)")#
axis(2,las=2)#
mtext("Risk (% extirpated)",2,line=2.5)#
#
sims_out <- subset(long_sims, control == 0.12 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
sims_out <- subset(long_sims, control == 0.25 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.5 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0.75 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Mgmt. control (C*)",cex=0.8)#
mtext("A",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
#####
sims_out <- subset(long_sims, control == 0 & MSY == 1)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0,25),xlim=c(0.8,3.1),yaxt="n",ylab="",xlab="")#
axis(2,las=2)#
mtext("Stability (1/CV)",1,line=1,outer=T)#
mtext("B",3,line=0.2,adj=-0.1,font=2,cex=1.3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.88)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.75)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.5)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
ext[ext<0]<-0#
points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
#
sims_out <- subset(long_sims, control == 0 & MSY == 0.25)#
x <- as.numeric(paste(sims_out[,1]))#
y <- as.numeric(paste(sims_out[,2]))#
z <-as.numeric(sims_out[,3]*100)#
data.loess= loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
ext<-as.matrix(predict(data.loess, newdata = grid))#
#
x <- as.numeric(paste(sims_out[,1]))+0.00000001#
y <- as.numeric(paste(sims_out[,2]))+0.00000001#
z <-as.numeric(1/sims_out[,4])#
data.loess = loess(z~x*y)#
grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
stability<-as.matrix(predict(data.loess, newdata = grid))#
#
points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
#
legend(2,24,c("1","0.88","0.75","0.5","0.25"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.8, bty="n")#
text(2.5,24,"Risk tolerance (P*)",cex=0.8)
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
## Functions for analysis#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add,for.error){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V#cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		#N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
		#Ntot[i,]=Ntot[i,]*rlnorm(1,0,for.error)#
			for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}#
risk_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx, row){#
  if(row == 1){ylim = 25}#
  if(row == 2){ylim = 10}#
  if(row == 3){ylim = 5}#
  sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0, ylim),xlim=c(0.75,2.75),yaxt="n",xaxt="n",ylab="",xlab="")#
  sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.75 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
  if(yaxis_plot=="TRUE"){#
    axis(2,las=2)  #
  }else{#
    axis(2,las=2,labels = F)  #
  }  #
  if(xaxis_plot=="TRUE"){#
    axis(1)  #
  }else{#
    axis(1,labels = F)  #
  }   #
  if(incl.legend == "TRUE"){#
    legend(1.5,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.7, bty="n")#
    text(2,24,"Mgmt. control (C*)",cex=0.7)#
  }#
}
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
## Functions for analysis#
#------------------------------------------------------------------------------##
# Status function; estimates equilibrium spwn abundance and catch plus whether #
# over fished or extinct#
#------------------------------------------------------------------------------##
#U <- harvest rate#
#a <- productivity#
#b <- density dependence #
SC.eq <- function(U,a,b){#
  a <- log(a)#
  S.eq <- max(0,(a-(-log(1-U)))/b)#
  C.eq <- max(0,((a-(-log(1-U)))/b)*exp(a-b*((a-(-log(1-U)))/b))-((a-(-log(1-U)))/b))#
  OF <- ifelse(U>0.5*a-0.07*a^2,1,0)#
  EX <- ifelse(S.eq==0,1,0)#
  return(c(S.eq,C.eq,OF,EX))#
  }#
#------------------------------------------------------------------------------##
# Multi-stock simulation function#
#------------------------------------------------------------------------------##
# ny <- the number of years on top of a 20 year initialization#
# Ro <- the sub-stock recruiment at time zero#
# vcov.matrix <- the expected correlation in recruitment within and among stocks#
# rho <- the expected correlation among stocks#
# phi <- the expected correlation through time#
# Preturn <- the expected proportion of spawners from age 4-7#
# episd <- random recruitment variation#
# alpha <- sub-stock productivity (not in log space)#
# beta <- sub-stock density dependence #
# control <- degree of management control (1 is perfect stock specific Umsy, 0 is aggregate Umsy)#
# MSY.add <- degree of downward adjustment of Umsy (e.g., 1 is none, 0.5 is 50% reduction in realized harvest rate) #
process = function(ny,Ro,rho,phi,Preturn,U,alpha,beta,control,MSY.add,for.error){#
	ny = ny+20#
	ns = length(Ro) #number of sub-stocks#
	#Create correlation among stocks in recruitment residuals#
	R <- matrix(rho,ns,ns) #correlation matrix#
	for(i in 1:ns)R[i,i] <- 1#
	V <- diag(rep(episd,ns)) # diagonal matrix of sqrt(variances)#
	Sig <- V %*% R %*% V#cov matrix#
	epi = rmvnorm(n=ny, sigma=Sig)#
	#Build time series of Spawners (S), abundance of returning spawners pre-harvest#
	# (N), and the component of the residual that is correlated throught time (v)#
	R = t(matrix(Ro,ns,ny))#
	S = R * (1-0)#
	v = R; v[,]=0#
	R[1:7,]=t(replicate(7,Ro,simplify=T))*exp(epi[1:7,])#
	N = array(0,dim=c(ny,4,ns))#
	Ntot = R; Ntot[,]=0#
	H = Ntot#
	S = Ntot#
	predR = Ntot#
	N[5:7,1,]=R[5:7-(4),]*Preturn[1]#
	N[6:7,2,]=R[6:7-(5),]*Preturn[2]#
	N[7,3,]=R[7-(6),]*Preturn[3]#
	# Loop through years of simulation	  #
	for(i in (7+1):ny){#
		N[i,1,]=R[i-(4),]*Preturn[1]#
		N[i,2,]=R[i-(5),]*Preturn[2]#
		N[i,3,]=R[i-(6),]*Preturn[3]#
		N[i,4,]=R[i-(7),]*Preturn[4]#
		#N[N[,,]=='NaN'] <- 0#
		Ntot[i,]=colSums(N[i,,])#
		#Ntot[i,]=Ntot[i,]*rlnorm(1,0,for.error)#
			for (yy in 1:length(alpha)){#
			u <- master.har[which.min(abs(master.har[,1,yy]-(Ntot[i,yy]))),2,yy]*control + #
					master.har[which.min(abs(master.har[,1,length(alpha)+1]-sum(Ntot[i,]))),2,length(alpha)+1]*(1-control)#
		outcome_error <- (1+rnorm(1,0,OU))#
		H[i,yy] =  Ntot[i,yy] * u *ifelse(outcome_error<0, 0, outcome_error)*MSY.add 			#
			}#
		S_exp = Ntot[i,]-H[i,] ; S_exp[S_exp<0] = 0#
		S[i,] = S_exp#
		S[i,S[i,]<50] = 0 # drive pops below a threshold to extinction#
		R[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,]+phi*v[i-1,]+epi[i,])#
		predR[i,] = alpha[]*S[i,]*exp(-beta[]*S[i,])#
		v[i,] = log(R[i,])-log(predR[i,])#
		v[i,is.nan(v[i,])]<-0#
}#
	#Output#
	S[S[,]=='NaN'] <- 0#
	Ntot[Ntot[,]=='NaN'] <- 0#
	pms <- matrix(NA,1,7) # performance measures: escapement, harvest, harvest rate, overfished, extinct, prop years failed to meet subsistance goal, CV in harvest#
	over<- matrix(NA,length(alpha))#
	ext<- matrix(NA,length(alpha))#
	harvest_rate <- (H[20:ny,]/Ntot[20:ny,])[,1]#
	for(j in 1:length(alpha)){#
		over[j] <- SC.eq(mean(harvest_rate),alpha[j],beta[j])[3]#
		ext[j] <- ifelse(median(S[(ny-20):ny,j]) < ((log(alpha)/beta)*0.05)[j],1,0) # less than 5% of unfished biomass/abundance#
		}#
	harvest <-rowSums(H[,])#
	pms[,1] <- sum(S[20:ny,])/(ny-19)#
	pms[,2] <- mean(harvest[(ny-20):ny]) #
	pms[,3] <- mean(harvest_rate)#
	pms[,4] <- sum(over)/length(alpha)#
	pms[,5] <- sum(ext)/length(alpha)#
	pms[,6] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	pms[,7] <- sd(harvest[(ny-20):ny])/mean(harvest[(ny-20):ny]) #
	list(S=S[20:ny,],N=Ntot[20:ny,],H=H[20:ny,],PMs=pms)#
	}#
#------------------------------------------------------------------------------##
# Function to generate matrix of alphas and betas#
#------------------------------------------------------------------------------#	#
# pops <- # of populations (MUST BE EVEN)#
# max.a <- maximum productivity#
# min.a <- minimum productivity#
# steps <- # of steps between high and low heterogenity#
# equ_spw <- equilibrium abundance (assumes all pops are the same size)#
# var_pop <- maintain eveness in variation in productivity across populations? ("Yes" or "No")#
hetero_prod_func = function(pops, max.a, min.a, steps, equ_spw,var_pop){#
	alpha.all <- array(NA,dim=c(steps,pops))#
	alpha.all[1,] <- rep(mean(c(max.a, min.a),pops))#
	alpha.all[steps,1] <- min.a#
	alpha.all[steps, pops] <- max.a#
	for(i in 2:pops){#
		alpha.all[steps,i] <- alpha.all[steps,i-1] + (max.a-min.a)/(pops-2)#
		for(ii in 2:(steps)){#
			alpha.all[ii,i-1] <- alpha.all[ii-1,i-1] - (alpha.all[1,i-1] - alpha.all[steps,i-1])/(steps-2)#
			alpha.all[ii, pops] <- alpha.all[ii-1, pops] - (alpha.all[1, pops] - alpha.all[steps, pops])/(steps-2)#
			}#
		}#
		if(var_pop == "Yes"){#
			alpha.all[,1:(pops/3)] <- alpha.all[,1]#
			alpha.all[,((pops/3)+1):((pops/3)+pops/3)] <- alpha.all[,(pops/2)+0.5]#
			alpha.all[,((pops)-(pops/3)+1):pops]  <- alpha.all[,pops]#
		}	#
	beta.all <- array(NA,dim=c(steps,pops))#
	beta.all <- log(alpha.all)/equ_spw#
	list(alphas = alpha.all,betas = beta.all)#
	}#
#------------------------------------------------------------------------------##
# Filled contour function by Ian Taylor, Carey McGilliard and Bridget Ferris#
#------------------------------------------------------------------------------##
filled.contour3 <-#
  function (x = seq(0, 1, length.out = nrow(z)),#
            y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
            ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
            levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
            col = color.palette(length(levels) - 1), plot.title, plot.axes, #
            key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
            axes = TRUE, frame.plot = axes,mar, ...) #
{#
  # modification by Ian Taylor of the filled.contour function#
  # to remove the key and facilitate overplotting with contour()#
  # further modified by Carey McGilliard and Bridget Ferris#
  # to allow multiple plots on one page#
  if (missing(z)) {#
    if (!missing(x)) {#
      if (is.list(x)) {#
        z <- x$z#
        y <- x$y#
        x <- x$x#
      }#
      else {#
        z <- x#
        x <- seq.int(0, 1, length.out = nrow(z))#
      }#
    }#
    else stop("no 'z' matrix specified")#
  }#
  else if (is.list(x)) {#
    y <- x$y#
    x <- x$x#
  }#
  if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
    stop("increasing 'x' and 'y' values expected")#
 # mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
 # on.exit(par(par.orig))#
 # w <- (3 + mar.orig[2]) * par("csi") * 2.54#
 # par(las = las)#
 # mar <- mar.orig#
 plot.new()#
 # par(mar=mar)#
  plot.window(xlim, ylim, "", xaxs = xaxs, yaxs = yaxs, asp = asp)#
  if (!is.matrix(z) || nrow(z) <= 1 || ncol(z) <= 1) #
    stop("no proper 'z' matrix specified")#
  if (!is.double(z)) #
    storage.mode(z) <- "double"#
	.filled.contour(as.double(x), as.double(y), z, as.double(levels), #
                            col = col)#
  if (missing(plot.axes)) {#
    if (axes) {#
      title(main = "", xlab = "", ylab = "")#
      Axis(x, side = 1)#
      Axis(y, side = 2)#
    }#
  }#
  else plot.axes#
  if (frame.plot) #
    box()#
  if (missing(plot.title)) #
    title(...)#
  else plot.title#
  invisible()#
}#
filled.legend <-#
  function (x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, #
    length.out = ncol(z)), z, xlim = range(x, finite = TRUE), #
    ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), #
    levels = pretty(zlim, nlevels), nlevels = 20, color.palette = cm.colors, #
    col = color.palette(length(levels) - 1), plot.title, plot.axes, #
    key.title, key.axes, asp = NA, xaxs = "i", yaxs = "i", las = 1, #
    axes = TRUE, frame.plot = axes, ...) #
{#
  # modification of filled.contour by Carey McGilliard and Bridget Ferris#
  # designed to just plot the legend#
    if (missing(z)) {#
        if (!missing(x)) {#
            if (is.list(x)) {#
                z <- x$z#
                y <- x$y#
                x <- x$x#
            }#
            else {#
                z <- x#
                x <- seq.int(0, 1, length.out = nrow(z))#
            }#
        }#
        else stop("no 'z' matrix specified")#
    }#
    else if (is.list(x)) {#
        y <- x$y#
        x <- x$x#
    }#
    if (any(diff(x) <= 0) || any(diff(y) <= 0)) #
        stop("increasing 'x' and 'y' values expected")#
  #  mar.orig <- (par.orig <- par(c("mar", "las", "mfrow")))$mar#
  #  on.exit(par(par.orig))#
  #  w <- (3 + mar.orig[2L]) * par("csi") * 2.54#
    #layout(matrix(c(2, 1), ncol = 2L), widths = c(1, lcm(w)))#
  #  par(las = las)#
  #  mar <- mar.orig#
  #  mar[4L] <- mar[2L]#
  #  mar[2L] <- 1#
  #  par(mar = mar)#
   # plot.new()#
    plot.window(xlim = c(0, 1), ylim = range(levels), xaxs = "i", #
        yaxs = "i")#
    rect(0, levels[-length(levels)], 1, levels[-1L], col = col)#
    if (missing(key.axes)) {#
        if (axes) #
            axis(4)#
    }#
    else key.axes#
    box()#
}#
risk_stab_plot <- function(long_sims, incl.legend, yaxis_plot, xaxis_plot, risk.tolerance, indexx, row){#
  if(row == 1){ylim = 25}#
  if(row == 2){ylim = 10}#
  if(row == 3){ylim = 7}#
  sims_out <- subset(long_sims, control == 0 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  plot(stability[indexx,], ext[indexx,],col=colors[5],type="l",lwd=3,ylim=c(0, ylim),xlim=c(0.75,2.75),yaxt="n",xaxt="n",ylab="",xlab="")#
  sims_out <- subset(long_sims, control == 0.12 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[4],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.25 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[3],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.5 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[2],type="l",lwd=3)#
  sims_out <- subset(long_sims, control == 0.75 & MSY == risk.tolerance)#
  x <- as.numeric(paste(sims_out[,1]))#
  y <- as.numeric(paste(sims_out[,2]))#
  z <-as.numeric(sims_out[,3]*100)#
  data.loess= loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  ext<-as.matrix(predict(data.loess, newdata = grid))#
  x <- as.numeric(paste(sims_out[,1]))+0.00000001#
  y <- as.numeric(paste(sims_out[,2]))+0.00000001#
  z <-as.numeric(1/sims_out[,4])#
  data.loess = loess(z~x*y)#
  grid = expand.grid(list(x = seq(0,1,length.out=100), y = seq(min_cor,1,length.out=100)))#
  stability<-as.matrix(predict(data.loess, newdata = grid))#
  ext[ext<0]<-0#
  points(stability[indexx,], ext[indexx,],col=colors[1],type="l",lwd=3)#
  if(yaxis_plot=="TRUE"){#
    axis(2,las=2)  #
  }else{#
    axis(2,las=2,labels = F)  #
  }  #
  if(xaxis_plot=="TRUE"){#
    axis(1)  #
  }else{#
    axis(1,labels = F)  #
  }   #
  if(incl.legend == "TRUE"){#
    legend(1.5,24,c("0","0.125","0.25","0.5","0.75"),lwd=3,lty=1,col=c(colors[5],colors[4],colors[3],colors[2],colors[1]),cex=0.7, bty="n")#
    text(2,24,"Mgmt. control (C*)",cex=0.7)#
  }#
}
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
saveRDS(master.sims_out,"mgmt_risk_sims.100.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Dec282018")
# Read in simulations, process#
risk_sims <-readRDS(file = "output/mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.OU_0.Dec282018")#
#long_sims <- round(risk_sims, digits = 2)#
long_sims <- round(master.sims_out , digits = 2)#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
# Read in simulations, process#
risk_sims <-readRDS(file = "mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.OU_0.Dec282018")#
#long_sims <- round(risk_sims, digits = 2)#
long_sims <- round(master.sims_out , digits = 2)#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
risk_sims <-readRDS(file = "mgmt_risk_sims.phi_0.8.Rho_0.6.logFE_0.OU_0.Dec282018")
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 200#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"mgmt_risk_sims.200.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Jan162019")
## Load functions and libraries for analysis#
source("functions_PC.R") #
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)#
library(ggplot2)#
library(gridExtra)#
library(ggpubr)
#------------------------------------------------------------------------------##
# Run simulations to generate figure 2 by populating a long form data frame with #
#	outcome of simulations (across a range of harvest and management control)#
#------------------------------------------------------------------------------##
###############
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
rho.all <- array(NA,dim=c(steps,1))#
rho.range <- seq(min_cor,0.99,length.out=steps)#
for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
  rho.all[ww,] <- rho.range[ww]#
}#
ny = 50#
num.sims <- 200#
phi <- 0.8#
episd <- 0.6#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0.0#
outcomes <- array(NA,dim=c(num.sims,7))#
mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 1#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
	for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add,for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- sims_out#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 1#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.75#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.75#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
##############
# no control, max harvest#
control <- 0 #
MSY.add <- 0.5#
for(ii in 1:steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# perfect control, max harvest#
control <- 1 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
# 0.125 control, max harvest#
control <- 0.125 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.25 control, max harvest#
control <- 0.25 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.375 control, max harvest#
control <- 0.375 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.5 control, max harvest#
control <- 0.5 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0.75 control, max harvest#
control <- 0.75 #
MSY.add <- 0.5#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]		#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#############################################
#################################################
# 0 control, 0.25 harvest#
control <- 0 #
MSY.add <- 0.25#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
#### 0 control, 0.875 harvest#
control <- 0#
MSY.add <- 0.875#
for(ii in 1: steps){#
  for(jj in 1: steps){#
    alpha<- inputs$alphas[ii,]#
    beta<- inputs$betas[ii,]#
    Ro <- log(alpha)/beta; sum(Ro)#
    rho <- rho.all[jj,]				#
    source("MSY_hcr_function.R")				#
    for (l in 1: num.sims){#
      out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
      outcomes[l,] <- out$PMs#
    }#
    mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
  }#
}#
sims_out.1 <- melt(mean_out[,,5])#
sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
master.sims_out <- rbind(master.sims_out,sims_out)#
saveRDS(master.sims_out,"mgmt_risk_sims.200.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Jan162019")
risk_sims <-readRDS(file = "mgmt_risk_sims.200.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Jan162019")
long_sims <- round(master.sims_out , digits = 2)#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
## Load functions and libraries for analysis#
source("functions_PC.R") #
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)#
library(ggplot2)#
library(gridExtra)#
library(ggpubr)
# Read in simulations, process#
risk_sims <-readRDS(file = "mgmt_risk_sims.200.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Jan162019")#
#long_sims <- round(risk_sims, digits = 2)#
long_sims <- round(master.sims_out , digits = 2)#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
# Read in simulations, process#
risk_sims <-readRDS(file = "mgmt_risk_sims.200.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Jan162019")#
long_sims <- round(risk_sims, digits = 2)#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
# Read in simulations, process#
risk_sims <-readRDS(file = "mgmt_risk_sims.200.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Jan162019")#
long_sims <- round(risk_sims, digits = 2)#
min_cor=0#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
# Read in simulations, process#
risk_sims <-readRDS(file = "mgmt_risk_sims.200.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Jan162019")#
long_sims <- round(risk_sims, digits = 2)#
min_cor=0#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
# Read in simulations, process#
risk_sims <-readRDS(file = "mgmt_risk_sims.200.phi_0.8.Rho_0.6.logFE_0.1.OU_0.Jan162019")#
long_sims <- round(risk_sims, digits = 2)#
min_cor=0#
jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan","#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))#
colors <- jet.colors(5)#
# Set up plotting region#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)#
#jpeg("figures/fig_4_heat_map_phi_0.8.Rho_0.6.logFE_0.OU_0.hetP2.jpeg",width=6, height=5.15, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)
jpeg("figures/fig_S3.jpeg",width=8, height=10, units="in",res=800)#
#dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)#
screen(3)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 90, 1)#
  mtext("Var. in productivity = high",3,line=0, cex=0.9)#
  mtext("Risk tolerance = high",4,line=0.5)#
screen(4)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "FALSE", 0.75, 20, 2)#
  mtext("Risk (% stocks extirpated)",2,line=2)#
screen(5)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 50, 2)#
screen(6)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 0.75, 90, 2)#
  mtext("Risk tolerance = medium",4,line=0.5)#
screen(7)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "TRUE", "TRUE", 0.5, 20, 3)#
screen(8)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 50, 3)#
  mtext("Catch stability (1/CV)",1,line=2.5)#
screen(9)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "TRUE", 0.5, 90, 3)#
  mtext("Risk tolerance = low",4,line=0.5)#
close.screen(all.screens = TRUE)#
dev.off()
dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1,new=F)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)
dev.new(width=8, height=10,new=FALSE)#
#par(mfrow=c(3,3),bty="o", mar=c(3,3,2.5,5),oma=c(2,2,1,1))#set dimensions to plots#
# ROW 1: Yield#
screen(1,new=T)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)
screen(1,new=T)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)
# ROW 1: Yield#
screen(1,new=T)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)#
screen(2)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "FALSE", "FALSE", "FALSE", 1, 50, 1)#
  mtext("Var. in productivity = medium",3,line=0, cex=0.9)
dev.new(width=8, height=10,new=FALSE)#
m <- rbind(#
  cbind(0.05,0.35,0.7,1),#
  cbind(0.35,0.65,0.7,1),#
  cbind(0.65,0.95,0.7,1),#
  cbind(0.05,0.35,0.4,0.7),#
  cbind(0.35,0.65,0.4,0.7),#
  cbind(0.65,0.95,0.4,0.7),#
  cbind(0.05,0.35,0.1,0.4),#
  cbind(0.35,0.65,0.1,0.4),#
  cbind(0.65,0.95,0.1,0.4),#
  cbind(0,1,0,1)#
  )#
split.screen(m)
# ROW 1: Yield#
screen(1,new=T)#
  par(mar = c(1,1.5,1,1))#
  risk_stab_plot(long_sims, "TRUE", "TRUE", "FALSE", 1, 20, 1)#
  mtext("Var. in productivity = low",3,line=0, cex=0.9)
## Load functions and libraries for analysis#
source("functions.R") #
#
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)#
library(ggplot2)#
library(gridExtra)#
library(ggpubr)#
library(viridis)
install.packages("ggpubr")
pops <- 12 # of populations (MUST BE EVEN)#
max.a <- 7 # maximum productivity#
min.a <- 2 # minimum productivity#
steps <- 10 # of steps between high and low heterogenity#
equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
min_cor <- -0.1 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
#
inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No") # generate matrix of alphas and betas#
alpha<- inputs$alphas[10,]#
beta<- inputs$betas[10,]#
Ro <- log(alpha)/beta; sum(Ro)#
#
Smsy <- (1-lambert_W0(exp(1-log(alpha))))/beta#
Uopt <- round(0.5* log(alpha)-0.07* log(alpha)^2,digits=2)#
#
ny = 50#
phi <- 0.4#
rho <- 0.4#
episd <- 0.4#
Preturn <- c(0,0,1,0)#
for.error <- 0.1#
OU <- 0#
#
num.sims <- 5#
#
time_period <- c(48:51)
control <- 0 #
MSY.add <- 1#
#
sim_output <- matrix(NA,pops,4,dimnames=list(NULL,c("S_Smsy","F_Fmsy","control","risk")))#
sim_output.2 <- matrix(NA,pops,4,dimnames=list(NULL,c("S_Smsy","F_Fmsy","control","risk")))#
#
source("MSY_hcr_function.R")				#
for (i in 1:num.sims){#
  out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
  if(i==1){#
    sim_output[,1] <- apply(out$S[48:51,],c(2),mean)/Smsy#
    sim_output[,2] <- apply(out$H[48:51,]/out$N[48:51,],c(2),mean)/Uopt#
    sim_output[,3] <- rep(control,pops)#
    sim_output[,4] <- rep(MSY.add,pops)#
  }else{#
    sim_output.2[,1] <- apply(out$S[48:51,],c(2),mean)/Smsy#
    sim_output.2[,2] <- apply(out$H[48:51,]/out$N[48:51,],c(2),mean)/Uopt#
    sim_output.2[,3] <- rep(control,pops)#
    sim_output.2[,4] <- rep(MSY.add,pops)#
#
      sim_output <- rbind(sim_output,sim_output.2)#
  }#
}#
#
full.sims.top <- sim_output#
#
# high risk, high mgmt control#
#
control <- 0.85#
MSY.add <- 1#
#
source("MSY_hcr_function.R")				#
for (i in 1:num.sims){#
  out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
  if(i==1){#
    sim_output[,1] <- apply(out$S[48:51,],c(2),mean)/Smsy#
    sim_output[,2] <- apply(out$H[48:51,]/out$N[48:51,],c(2),mean)/Uopt#
    sim_output[,3] <- rep(control,pops)#
    sim_output[,4] <- rep(MSY.add,pops)#
#
  }else{#
    sim_output.2[,1] <- apply(out$S[48:51,],c(2),mean)/Smsy#
    sim_output.2[,2] <- apply(out$H[48:51,]/out$N[48:51,],c(2),mean)/Uopt#
    sim_output.2[,3] <- rep(control,pops)#
    sim_output.2[,4] <- rep(MSY.add,pops)#
    sim_output <- rbind(sim_output,sim_output.2)#
  }#
}#
#
full.sims.top <- rbind(full.sims.top,sim_output)#
#
full.sims.top <- as.data.frame(full.sims.top)#
full.sims.top[,3] <- as.factor(full.sims.top[,3])#
full.sims.top[,4] <- as.factor(full.sims.top[,4])#
full.sims.top <- full.sims.top[complete.cases(full.sims.top),]#
#
# low risk, low mgmt control#
#
control <- 0 #
MSY.add <- 0.5#
#
sim_output <- matrix(NA,pops,4,dimnames=list(NULL,c("S_Smsy","F_Fmsy","control","risk")))#
sim_output.2 <- matrix(NA,pops,4,dimnames=list(NULL,c("S_Smsy","F_Fmsy","control","risk")))#
#
source("MSY_hcr_function.R")				#
for (i in 1:num.sims){#
  out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
  if(i==1){#
    sim_output[,1] <- apply(out$S[48:51,],c(2),mean)/Smsy#
    sim_output[,2] <- apply(out$H[48:51,]/out$N[48:51,],c(2),mean)/Uopt#
    sim_output[,3] <- rep(control,pops)#
    sim_output[,4] <- rep(MSY.add,pops)#
  }else{#
    sim_output.2[,1] <- apply(out$S[48:51,],c(2),mean)/Smsy#
    sim_output.2[,2] <- apply(out$H[48:51,]/out$N[48:51,],c(2),mean)/Uopt#
    sim_output.2[,3] <- rep(control,pops)#
    sim_output.2[,4] <- rep(MSY.add,pops)#
    sim_output <- rbind(sim_output,sim_output.2)#
  }#
}#
#
full.sims.bottom <- sim_output#
# low risk, high mgmt control#
#
control <- 0.85#
MSY.add <- 0.5#
#
source("MSY_hcr_function.R")				#
for (i in 1:num.sims){#
  out <- process(ny, Ro, rho, phi, Preturn, U, alpha, beta, control, MSY.add, for.error)#
  if(i==1){#
    sim_output[,1] <- apply(out$S[48:51,],c(2),mean)/Smsy#
    sim_output[,2] <- apply(out$H[48:51,]/out$N[48:51,],c(2),mean)/Uopt#
    sim_output[,3] <- rep(control,pops)#
    sim_output[,4] <- rep(MSY.add,pops)#
  }else{#
    sim_output.2[,1] <- apply(out$S[48:51,],c(2),mean)/Smsy#
    sim_output.2[,2] <- apply(out$H[48:51,]/out$N[48:51,],c(2),mean)/Uopt#
    sim_output.2[,3] <- rep(control,pops)#
    sim_output.2[,4] <- rep(MSY.add,pops)#
    sim_output <- rbind(sim_output,sim_output.2)#
  }#
}#
#
full.sims.bottom <- rbind(full.sims.bottom,sim_output)#
#
full.sims.bottom <- as.data.frame(full.sims.bottom)#
full.sims.bottom[,3] <- as.factor(full.sims.bottom[,3])#
full.sims.bottom[,4] <- as.factor(full.sims.bottom[,4])#
full.sims.bottom <- full.sims.bottom[complete.cases(full.sims.bottom),]#
btml <- rbind(full.sims.top[which(full.sims.top$control=="0"),],full.sims.bottom[which(full.sims.bottom$control=="0"),])#
#
btmr <- rbind(full.sims.top[which(full.sims.top$control=="0.85"),],full.sims.bottom[which(full.sims.bottom$control=="0.85"),])
p1 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,4))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"))+#
  geom_point(color="blue",fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)  #
p2 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"))+#
  geom_point(color='green',fill='green',size=2,alpha=0.45,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)  #
#
p3 <- ggplot() + #
  geom_density(data=full.sims.top, aes(x=F_Fmsy, group=control,fill=control),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("blue", "green"))+#
  coord_flip()+ #
  scale_x_continuous("",limits = c(0,4),position = "top",labels=NULL)+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(2,4,0,0), "lines"))+#
  geom_vline(xintercept=1)#
#
p4 <- ggplot(data = full.sims.bottom[which(full.sims.bottom$control=="0"),],aes(S_Smsy, F_Fmsy))+#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,4))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"))+#
  geom_point(color='red',fill='red',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5) #
#
p5 <- ggplot( data = full.sims.bottom[which(full.sims.bottom$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"))+#
  geom_point(color='black',fill='black',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5) #
#
p6 <- ggplot() + #
  geom_density(data=full.sims.bottom, aes(x=F_Fmsy, group=control,fill=control),alpha=0.65, adjust=3)+ #
  scale_fill_manual(values=c("red", "black"))+#
  coord_flip()+ #
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(1,4,1,0), "lines"))+#
  geom_vline(xintercept=1)#
#
p7 <- ggplot() + #
  geom_density(data=btml, aes(x=S_Smsy, group=risk,fill=risk),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("blue", "red"))+#
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(-0.75,-0.5,4,1.35), "lines"))+#
  geom_vline(xintercept=1)+ #
  scale_y_reverse()#
#
p8 <- ggplot() + #
  geom_density(data=btmr, aes(x=S_Smsy, group=risk,fill=risk),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("green", "black"))+#
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(-0.75,-0.5,4,0.75), "lines"))+#
  geom_vline(xintercept=1)+ #
  scale_y_reverse()
ggarrange(p1,p2,p3,p4,p5,p6,p7,p8, labels = c("A", "B", "C", "D", "E", "F", "G", "H"))
library(ggpubr)
ggarrange(p1,p2,p3,p4,p5,p6,p7,p8, labels = c("A", "B", "C", "D", "E", "F", "G", "H"))
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Reds", direction=1)
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="blue", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,4))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"))+#
  geom_point(size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="blue", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"))+#
  geom_point(size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="blue", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="blue", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
p1 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="blue", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines", legend.position="none"), legend.position="none")+#
  geom_point(color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)  #
p2 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0.85"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="blue", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines", legend.position="none"))+#
  geom_point(color='green',fill='green',size=2,alpha=0.45,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)  #
#
p3 <- ggplot() + #
  geom_density(data=full.sims.top, aes(x=F_Fmsy, group=control,fill=control),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("blue", "green"))+#
  coord_flip()+ #
  scale_x_continuous("",limits = c(0,4),position = "top",labels=NULL)+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(2,4,0,0), "lines"))+#
  geom_vline(xintercept=1)#
#
p4 <- ggplot(data = full.sims.bottom[which(full.sims.bottom$control=="0"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="red", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,4))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='red',fill='red',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5) #
#
p5 <- ggplot( data = full.sims.bottom[which(full.sims.bottom$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="black", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='black',fill='black',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5) #
#
p6 <- ggplot() + #
  geom_density(data=full.sims.bottom, aes(x=F_Fmsy, group=control,fill=control),alpha=0.65, adjust=3)+ #
  scale_fill_manual(values=c("red", "black"))+#
  coord_flip()+ #
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(1,4,1,0), "lines"))+#
  geom_vline(xintercept=1)#
#
p7 <- ggplot() + #
  geom_density(data=btml, aes(x=S_Smsy, group=risk,fill=risk),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("blue", "red"))+#
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(-0.75,-0.5,4,1.35), "lines"))+#
  geom_vline(xintercept=1)+ #
  scale_y_reverse()#
#
p8 <- ggplot() + #
  geom_density(data=btmr, aes(x=S_Smsy, group=risk,fill=risk),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("green", "black"))+#
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(-0.75,-0.5,4,0.75), "lines"))+#
  geom_vline(xintercept=1)+ #
  scale_y_reverse()
ggarrange(p1,p2,p3,p4,p5,p6,p7,p8, labels = c("A", "B", "C", "D", "E", "F", "G", "H"))
p1 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines", legend.position="none"), legend.position="none")+#
  geom_point(color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)  #
p2 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0.85"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="greens", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines", legend.position="none"))+#
  geom_point(color='green',fill='green',size=2,alpha=0.45,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)
p1 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines", legend.position="none"), legend.position="none")+#
  geom_point(color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)  #
p2 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0.85"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greens", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines", legend.position="none"))+#
  geom_point(color='green',fill='green',size=2,alpha=0.45,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)  #
#
p3 <- ggplot() + #
  geom_density(data=full.sims.top, aes(x=F_Fmsy, group=control,fill=control),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("blue", "green"))+#
  coord_flip()+ #
  scale_x_continuous("",limits = c(0,4),position = "top",labels=NULL)+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(2,4,0,0), "lines"))+#
  geom_vline(xintercept=1)#
#
p4 <- ggplot(data = full.sims.bottom[which(full.sims.bottom$control=="0"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Reds", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,4))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='red',fill='red',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5) #
#
p5 <- ggplot( data = full.sims.bottom[which(full.sims.bottom$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blacks", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='black',fill='black',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5) #
#
p6 <- ggplot() + #
  geom_density(data=full.sims.bottom, aes(x=F_Fmsy, group=control,fill=control),alpha=0.65, adjust=3)+ #
  scale_fill_manual(values=c("red", "black"))+#
  coord_flip()+ #
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(1,4,1,0), "lines"))+#
  geom_vline(xintercept=1)#
#
p7 <- ggplot() + #
  geom_density(data=btml, aes(x=S_Smsy, group=risk,fill=risk),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("blue", "red"))+#
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(-0.75,-0.5,4,1.35), "lines"))+#
  geom_vline(xintercept=1)+ #
  scale_y_reverse()#
#
p8 <- ggplot() + #
  geom_density(data=btmr, aes(x=S_Smsy, group=risk,fill=risk),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("green", "black"))+#
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(-0.75,-0.5,4,0.75), "lines"))+#
  geom_vline(xintercept=1)+ #
  scale_y_reverse()
ggplot( data = full.sims.bottom[which(full.sims.bottom$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greys", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='black',fill='black',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5)
p1 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines", legend.position="none"), legend.position="none")+#
  geom_point(color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)  #
p2 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0.85"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greens", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines", legend.position="none"))+#
  geom_point(color='green',fill='green',size=2,alpha=0.45,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)
p1 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
p2 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0.85"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greens", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(color='green',fill='green',size=2,alpha=0.45,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)
p4 <- ggplot(data = full.sims.bottom[which(full.sims.bottom$control=="0"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Reds", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,4))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='red',fill='red',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5)
p5 <- ggplot( data = full.sims.bottom[which(full.sims.bottom$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greys", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='black',fill='black',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5)
p6 <- ggplot() + #
  geom_density(data=full.sims.bottom, aes(x=F_Fmsy, group=control,fill=control),alpha=0.65, adjust=3)+ #
  scale_fill_manual(values=c("red", "black"))+#
  coord_flip()+ #
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(1,4,1,0), "lines"))+#
  geom_vline(xintercept=1)#
#
p7 <- ggplot() + #
  geom_density(data=btml, aes(x=S_Smsy, group=risk,fill=risk),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("blue", "red"))+#
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(-0.75,-0.5,4,1.35), "lines"))+#
  geom_vline(xintercept=1)+ #
  scale_y_reverse()#
#
p8 <- ggplot() + #
  geom_density(data=btmr, aes(x=S_Smsy, group=risk,fill=risk),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("green", "black"))+#
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(-0.75,-0.5,4,0.75), "lines"))+#
  geom_vline(xintercept=1)+ #
  scale_y_reverse()
ggarrange(p1,p2,p3,p4,p5,p6,p7,p8, labels = c("A", "B", "C", "D", "E", "F", "G", "H"))
p1 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)  #
p2 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greens", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(color='green',fill='green',size=2,alpha=0.45,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)  #
#
p3 <- ggplot() + #
  geom_density(data=full.sims.top, aes(x=F_Fmsy, group=control,fill=control),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("blue", "green"))+#
  coord_flip()+ #
  scale_x_continuous("",limits = c(0,4),position = "top",labels=NULL)+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(2,4,0,0), "lines"))+#
  geom_vline(xintercept=1)#
#
p4 <- ggplot(data = full.sims.bottom[which(full.sims.bottom$control=="0"),aes(S_Smsy, F_Fmsy)])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Reds", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,4))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='red',fill='red',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5) #
#
p5 <- ggplot( data = full.sims.bottom[which(full.sims.bottom$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greys", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='black',fill='black',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5) #
#
p6 <- ggplot() + #
  geom_density(data=full.sims.bottom, aes(x=F_Fmsy, group=control,fill=control),alpha=0.65, adjust=3)+ #
  scale_fill_manual(values=c("red", "black"))+#
  coord_flip()+ #
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(1,4,1,0), "lines"))+#
  geom_vline(xintercept=1)#
#
p7 <- ggplot() + #
  geom_density(data=btml, aes(x=S_Smsy, group=risk,fill=risk),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("blue", "red"))+#
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(-0.75,-0.5,4,1.35), "lines"))+#
  geom_vline(xintercept=1)+ #
  scale_y_reverse()#
#
p8 <- ggplot() + #
  geom_density(data=btmr, aes(x=S_Smsy, group=risk,fill=risk),alpha=0.65, adjust=2)+ #
  scale_fill_manual(values=c("green", "black"))+#
  scale_x_continuous(limits = c(0,4))+#
  theme(panel.background = element_blank(),axis.text = element_blank(), axis.ticks=element_blank(),axis.title=element_blank())+ #
  theme(legend.position="none",plot.margin = unit(c(-0.75,-0.5,4,0.75), "lines"))+#
  geom_vline(xintercept=1)+ #
  scale_y_reverse()
ggarrange(p1,p2,p3,p4,p5,p6,p7,p8, labels = c("A", "B", "C", "D", "E", "F", "G", "H"))
ggplot( data = full.sims.bottom[which(full.sims.bottom$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greys", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='black',fill='black',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5)
ggplot( data = full.sims.bottom[which(full.sims.bottom$control=="0.85"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greys", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  geom_point(color='black',fill='black',size=2,alpha=0.65,shape=16) +#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5)
ggplot( data = full.sims.bottom[which(full.sims.bottom$control=="0.85"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greys", direction=1) +#
  scale_x_continuous("",limits = c(0,4),labels = NULL)+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(1,0.2,0,0), "lines"), legend.position="none")+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = Low",size=2.5)
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] )+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(,aes(S_Smsy, F_Fmsy),color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
ggplot(data = full.sims.top[which(full.sims.top$control=="0")] )+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(,aes(S_Smsy, F_Fmsy),color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
full.sims.top[which(full.sims.top$control=="0")]
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] )+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(,aes(S_Smsy, F_Fmsy),color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),aes(S_Smsy, F_Fmsy)] )+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(,aes(S_Smsy, F_Fmsy),color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),] ,aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(,aes(S_Smsy, F_Fmsy),color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
full.sims.top[which(full.sims.top$control=="0.85"),]
full.sims.top[which(full.sims.top$control=="0"),]
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),])+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(,aes(S_Smsy, F_Fmsy),color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
ggplot(data = full.sims.top[which(full.sims.top$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greens", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(color='green',fill='green',size=2,alpha=0.45,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(,aes(S_Smsy, F_Fmsy),color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
ggplot(data = full.sims.top[which(full.sims.top$control=="0"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(aes(S_Smsy, F_Fmsy),color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
p1 <- ggplot(data = full.sims.top[which(full.sims.top$control=="0"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Blues", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous(name=bquote(" F/ "* F[MSY]),limits = c(0,3))+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(aes(S_Smsy, F_Fmsy),color='blue',fill='blue',size=2,alpha=0.65,shape=16)+#
  annotate("text", x=2.5, y=3,   label= "Mgmt. control = Low",size=2.5) + #
  annotate("text", x=2.5, y=2.65, label= "Risk tolerance = High",size=2.5)
p1
ggplot(data = full.sims.top[which(full.sims.top$control=="0.85"),],aes(S_Smsy, F_Fmsy))+#
  stat_density_2d(aes(x= S_Smsy, y=F_Fmsy, fill = stat(level)), geom = "polygon") +#
  scale_fill_distiller(palette="Greens", direction=1) +#
  scale_x_continuous(name=bquote(" S/"* S[MSY]),limits = c(0,4),position = "top")+#
  scale_y_continuous("",limits = c(0,4),labels = NULL)+#
  geom_vline(xintercept=1)+#
  geom_hline(yintercept=1)+#
  theme_bw()+#
  theme(panel.background = element_blank(),panel.grid = element_blank(),plot.margin = unit(c(0,0.2,0.2,0), "lines"), legend.position="none")+#
  geom_point(color='green',fill='green',size=2,alpha=0.45,shape=16)+#
  annotate("text", x=2.5, y=4,   label= "Mgmt. control = High",size=2.5) + #
  annotate("text", x=2.5, y=3.65, label= "Risk tolerance = High",size=2.5)
#--------------------------------------------------------------------------------------------##
#Puntledge entrainment model functions. Last updated: July 24 2014##
#--------------------------------------------------------------------------------------------##
#
	#-----------------------------------------##
	#survival and growth functions##
	#-----------------------------------------##
	mar.surv.func<-function(x)#
		{0.00001941*exp(0.04664646*(x))}#
#
	river.mort<-function(x)#
		{0.0225+((0.0-0.0195)/(1+exp(-0.1*(x-50))))}#
#
	est.mort<-function(x)#
		{0.0425+((0.0000-0.0395)/(1+exp(-0.0865*(x-50))))}#
#
	growth.rate.rv<-function(x,y)#
		{(0.056+0.6*(x^11.6/((x^11.6)+(114^11.6))))*y}#
	growth.rate.est<-function(x,y)#
		{(0.115+0.75*(x^11.6/((x^11.6)+(104^11.6))))*y}#
#
	size.fn<-function(x)#
		{-0.0000004100*x^4+0.0001898116*x^3+-0.0269704457*x^2+1.5627522796*x+6.0567104783}#
	#----------------------------------##
	#eicher efficiency function##
	#----------------------------------##
	eich.eff.fn<- function(FL,CF,MW)#
	{#
	#base effect#
	if(MW==10){x1<-0.98 - 0.01*(0+((50-FL)/10))}#
	if(MW==18){x1<-0.98 - 0.05*(0+((50-FL)/10))}#
	if(MW==24){x1<-0.93 - 0.15*(0+((50-FL)/10))}#
#
	#rate of decline in efficiency#
	if(MW==10){x2<-(CF/9*0.0025)*(0+((50-FL)/10))}#
	if(MW==18){x2<-(CF/9*0.017)*(0+((50-FL)/10))}#
	if(MW==24){x2<-(CF/9*0.04)*(0+((50-FL)/10))}#
#
	eff<-x1-(x2*x1)#
	if(eff<0.25){eff<-0.25}#
	if(eff>0.98){eff<-0.98}#
	eff#
	 }
#------------------------------------------------------##
#PSC model. Last updated: Aug 6,  2014##
#------------------------------------------------------##
#
#the following are the variables that need to be specified in the model function (e.g., psc.model(0,"baseline",10,"distribution","variable",0,0))#
#prop.hatch #(0 to 1) -- proportion of total spawners that are retained at hatchery#
#scenario #("baseline","entrain") -- whether baseline conditions are modelled or system with hydro operations#
#MW #(10,18,24) -- power generation scenario#
#fry.model #("fixed","distribution") -- whether model tracks 1000 fry per time step or fry based on empirical distribution#
#spill #("fixed","variable") -- which scenario for spill is modelled (variable or fixed)#
#clean.time #timing of cleaning of eicher screen in weeks since February 1 #
#maint.time #timing of cleaning of eicher screen in weeks since February 1 #
#spawn #number of sucessful spawners (for 2013 == 105)#
#PSM #pre-spawn mortality for wild fish#
source("model_functions.R")	 #load growth, mortality and eicher efficiency functions#
#
psc.model<-function(prop.hatch,scenario,MW,fry.model,spill,clean.time,maint.time,spawn,PSM){ #PSC model function#
	#-------------------------------------------------##
	#set initial conditions and parameters##
	#-------------------------------------------------##
	weeks<-26 #set up time frame for model#
	time<-seq(1,26,1 )#set time (in weeks from February 1)#
	fish<- array(NA,dim=c(weeks)) #set placeholder for fish abundance#
	final.fish<-fish[] #set placeholder for final fish abundance#
#
	prop.late<-0.5 #proportion of fish that spawn in upper watershed#
	wild.egg.fry<-0.4 #wild egg to fry survival#
	hatch.egg.fry<-0.8 #hatchery egg to fry survival#
	early.egg.beta<-1000000 #egg carrying capacity in headpond#
	late.egg.beta<-1000000 #egg carrying capacity in upper watershed#
	fecundity<-4650 #fecundity of Chinook#
	hatch.fry.size<-75 #size of fry at release from hatchery#
	hatch.surv.rel.wld<-0.5 #survival of hatchery fry relative to wild fry#
	hatch.init.mort<-0.25 #mortality of wild fry upon release#
	size<-size.fn(35+time*7) #size of wild fry at time t#
	size.hatch<-seq(hatch.fry.size,hatch.fry.size,length.out=26) #size of hatchery fry at time t#
	#-----------------------------------------------------------------------------##
	#timing and abundnce of outmigrating fry by spawner type##
	#-----------------------------------------------------------------------------##
	if (fry.model=="distribution"){#
				#--------------------------------------------##
				#breakdown of spawners by group##
				#--------------------------------------------##
				spawn.early<-spawn*(1-prop.late)*(1-prop.hatch)#
				spawn.late<-spawn*prop.late*(1-prop.hatch)#
				spawn.hatch<-spawn*prop.hatch#
				#--------------------------------##
				#spawner to egg survival##
				#--------------------------------#					#
				early.eggs<-(spawn.early*0.5*fecundity)/(1+(0.5*fecundity/early.egg.beta)*spawn.early)#
				late.eggs<-(spawn.late*0.5*fecundity)/(1+(0.5*fecundity/late.egg.beta)*spawn.late)#
				#------------------------##
				#egg to fry survival##
				#------------------------#				#
				early.emerge.fry<-early.eggs*wild.egg.fry#
				late.emerge.fry<-late.eggs*wild.egg.fry     #
				hatch.fry<-spawn.hatch*0.5*fecundity*hatch.egg.fry#
#
				#--------------------------------------------------##
				#timing and distribution of outmigrants##
				#--------------------------------------------------#				#
				peak.early<-85 #3rd week of march; peak early migration in 2013#
				peak.late<-161 #3rd week of june; peak lake migration in 2013#
				peak.hatch<-131#3rd week of june for release of hatchery fry#
				sd.early<-20#SD on early fry peak migration#
				sd.late<-14#SD on late fry peak migration#
				sd.hatch<-0#SD on lake residence before downstream migration#
				early.fry.sample<-rnorm(early.emerge.fry,peak.early,sd.early)#
				late.fry.sample<-rnorm(late.emerge.fry,peak.late,sd.late)#
				hatch.fry.sample<-rnorm(hatch.fry,peak.hatch,sd.hatch)#
				early.fry.week<-as.vector(table(cut(early.fry.sample,breaks=seq(0,365,by=7))))#
				late.fry.week<-as.vector(table(cut(late.fry.sample,breaks=seq(0,365,by=7))))#
				hatch.fry.week<-as.vector(table(cut(hatch.fry.sample,breaks=seq(0,365,by=7))))#
				early.fry.outmigration<-early.fry.week[5:30]#
				early.fish<-early.fry.outmigration*((1-river.mort(40))^7)				#
				hatch.fry.outmigration<-hatch.fry.week[5:30]#
				hatch.fish<-hatch.fry.outmigration*(1-hatch.init.mort)#
				late.fry.outmigration<-late.fry.week[5:30]#
#
				#---------------------------------------------------------------------------------------------------##
				#estimate size at emergence and survival prior to encountering PUN facility##
				#---------------------------------------------------------------------------------------------------##
				size.start<-time[];surv.up.rv<-time[];late.fish<-time[]#
				for(i in 1:26){	#
					grow.up.rv<-array(NA,dim=c(time[i]*7))#
					size.up.rv<-array(NA,dim=c(time[i]*7))#
					surv<-array(NA,dim=c(time[i]*7))#
					for(j in 1:length(1:round(time[i]*7))){#
						DOY<-(peak.late-99)+((time[i]*7)-j)#
						grow.up.rv[j]<-growth.rate.rv(DOY,1)#
						size.up.rv[j]<-size[i]-sum(grow.up.rv[1:j])#
						surv[j]<-1-(river.mort(size.up.rv[j]))#
										}#
						size.start[i]<-tail(size.up.rv,1)#
						surv.up.rv[i]<-prod(surv)#
						late.fish[i]<-late.fry.outmigration[i]*surv.up.rv[i]#
						start.fish<-early.fish+late.fish#
									}#
	}else {#
				start.fish<-seq(1000,1000,length.out=26)#
				}				#
	fry.start<-late.fry.outmigration+early.fry.outmigration#
	#-------------------------------------------------------------##
	#spill and river residence parameter estimates##
	#-------------------------------------------------------------##
	total.entrain.mort<-1 #mortality if entrained#
	lat.mort.eich<-fish[];lat.mort.eich[1:26]<-0.05#latent mortality of fish that are diverted by eicher screen#
	rv.residence<-c(5,4.5,4,3.5,3,2.5,2,2,2,2,2,1.5,1,1,1,1,1,1,1,1,1,1,0.5,0.1,0.1,0.1)#river residence time to match peak early fry estuary entry of ~ late April/early May#
	p.pen<-fish[];p.pen[1:length(fish[])]<-0.21#probablity of being diverted into penstock (i.e, not being diverted downstream in spill)}	#
#
	if(spill=="variable"){#probabilities of being diverted over diversion dam in spill#
			if(MW=="10"){#
				spill.p<-c(0.25,0.24,0.26,0.35,0.43,0.44,0.51,0.47,0.45,0.27,0.26,0.38,0.53,0.55,0.77,0.73,0.52,0.48,0.58,0.29,0.41,0.6,0.5,0.3,0.3,0.3)#
				p.pen<-1-spill.p}#
			if(MW=="18"){#
				spill.p<-c(0.22,0.22,0.22,0.22,0.22,0.22,0.28,0.22,0.22,0.22,0.22,0.22,0.31,0.34,0.66,0.59,0.3,0.23,0.38,0.22,0.22,0.42,0.27,0.22,0.22,0.22)#
				p.pen<-1-spill.p}		#
			if(MW=="24"){#
				spill.p<-c(0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175,0.175)#
				p.pen<-1-spill.p}#
				}#
	#---------------------------------------------------------------##
	#calculate cummulative flow/time since cleaning##
	#---------------------------------------------------------------##
		clean.start.1<- clean.time; shutdown<-maint.time#
        CF<-fish[];CF<-200+time*9#assuming increase of 5 Mms per week #
        post.clean.1<-seq(1:length(CF[clean.start.1:length(fish[])]))#
        post.clean.2<-seq(1:length(CF[shutdown:length(fish[])]))#
#
        if(clean.time<maint.time){#
        	CF[clean.start.1:length(fish[])]<-(post.clean.1-1)*9#
			CF[(shutdown+1):length(fish[])]<-c(0,(post.clean.2)*9);CF[shutdown]<-0#
					}#
        if(clean.time>maint.time){#
			CF[(shutdown+1):length(fish[])]<-c(0,(post.clean.2)*9);CF[shutdown]<-0#
        	CF[clean.start.1:length(fish[])]<-(post.clean.1-1)*9#
					}		#
		 if(clean.time==maint.time){#
			CF[(shutdown+1):length(fish[])]<-c(0,(post.clean.2)*9);CF[shutdown]<-0#
					}		#
		if(clean.time==0){#
			if(maint.time==0){CF<-fish[];CF<-200+time*9#assuming increase of 5 Mms per week #
					} #
				}#
	#------------------------------------------------------------------------------------------##
	#calculate eicher efficiency based on fish size and cummulative flow##
	#------------------------------------------------------------------------------------------#	#
			eich.eff<-fish[]#
			for(i in 1:length(size)){eich.eff[i]<-eich.eff.fn(size[i],CF[i],MW)}#
			if(maint.time==26){eich.eff[shutdown]<-1}else{eich.eff[shutdown]<-1;eich.eff[(shutdown+1)]<-1}#
			eich.eff[clean.start.1]<-1#
#
			eich.eff.hatch<-fish[]#
			for(i in 1:length(size.hatch)){eich.eff.hatch[i]<-eich.eff.fn(size.hatch[i],CF[i],MW)}#
			if(maint.time==26){eich.eff[shutdown]<-1}else{eich.eff[shutdown]<-1;eich.eff[(shutdown+1)]<-1}#
			eich.eff[clean.start.1]<-1#
#
    #------------------------------------##
    #track fish through life cycle##
    #------------------------------------#	#
#
		#------------------------------------------------------------------------##
		#1. migration down river - interaction with eicher screen##
		#------------------------------------------------------------------------#				#
			early.fish.entrain.out.pen<-early.fish*p.pen*(1-eich.eff)*(1-total.entrain.mort)#
			early.fish.entrain.out.rv<-early.fish*p.pen*(eich.eff)*(1-lat.mort.eich)#
			early.fish.out.rv<-early.fish*(1-p.pen)#
#
			late.fish.entrain.out.pen<-late.fish*p.pen*(1-eich.eff)*(1-total.entrain.mort)#
			late.fish.entrain.out.rv<-late.fish*p.pen*(eich.eff)*(1-lat.mort.eich)#
			late.fish.out.rv<-late.fish*(1-p.pen)#
#
			hatch.fish.entrain.out.pen<-hatch.fish*p.pen*(1-eich.eff.hatch)*(1-total.entrain.mort)#
			hatch.fish.entrain.out.rv<-hatch.fish*p.pen*(eich.eff.hatch)*(1-lat.mort.eich)#
			hatch.fish.out.rv<-hatch.fish*(1-p.pen)#
			if (scenario=="baseline")#
			{#
				if (fry.model=="distribution"){#
				early.total.rv<-early.fish#
				late.total.rv<-late.fish#
				hatch.total.rv<-hatch.fish#
							}else {#
				early.total.rv<-start.fish*(1-prop.late)*(1-prop.hatch)#
				late.total.rv<-start.fish*prop.late*(1-prop.hatch)#
				hatch.total.rv<-start.fish*prop.hatch}				#
							}else {#
				early.total.rv<-early.fish.entrain.out.pen+early.fish.entrain.out.rv+early.fish.out.rv#
				late.total.rv<-late.fish.entrain.out.pen+late.fish.entrain.out.rv+late.fish.out.rv#
				hatch.total.rv<-hatch.fish.entrain.out.pen+hatch.fish.entrain.out.rv+hatch.fish.out.rv#
			}#
		#-----------------------------------------------------------##
		#2. migration down river - growth and survival##
		#-----------------------------------------------------------##
				size.out.rv<-fish[];out.surv<-fish[];size.out.rv.hatch<-fish[];out.surv.hatch<-fish[]#
				for(i in 1:26){	#
				grow.rv<-array(NA,dim=c(round(rv.residence[i]*7)))#
				size.rv<-array(NA,dim=c(round(rv.residence[i]*7)))#
				surv.rv<-array(NA,dim=c(round(rv.residence[i]*7)))#
				size.hatch.rv<-array(NA,dim=c(round(rv.residence[i]*7)))#
				surv.hatch.rv<-array(NA,dim=c(round(rv.residence[i]*7)))#
					for(j in 1:round(rv.residence[i]*7)){#
							DOY<-32+((time[i]*7)+j)#
							grow.rv[j]<-growth.rate.rv(DOY,1)#
							size.rv[j]<-size[i]+sum(grow.rv[1:j])#
							surv.rv[j]<-1-(river.mort(size.rv[j]))#
							size.hatch.rv[j]<-size.hatch[i]+sum(grow.rv[1:j])#
							surv.hatch.rv[j]<-1-(river.mort(size.hatch.rv[j]))#
							}#
					out.surv[i]<-prod(surv.rv[])#
					out.surv.hatch[i]<-prod(surv.rv[])#
					size.out.rv[i]<-tail(size.rv,1)#
					size.out.rv.hatch[i]<-tail(size.hatch.rv,1)#
								}								#
			early.total.rv.out<-early.total.rv*out.surv			#
			late.total.rv.out<-late.total.rv*out.surv			#
			hatch.total.rv.out<-hatch.total.rv*out.surv.hatch *(hatch.surv.rel.wld)#
			total.rv.out<-early.total.rv.out+late.total.rv.out+hatch.total.rv.out#
#
		#------------------------------------------##
		#3. estuary - growth and survival##
		#------------------------------------------##
			est.time<-((rev(time)-rv.residence)*7)#
			size.out.est<-fish[];est.surv<-fish[];size.out.est.hatch<-fish[];est.surv.hatch<-fish[]#
			for(i in 1:26){	#
				grow.est<-array(NA,dim=c(est.time[i]))#
				size.est<-array(NA,dim=c(est.time[i]))#
				surv.est<-array(NA,dim=c(est.time[i]))#
				size.hatch.est<-array(NA,dim=c(est.time[i]))#
				surv.hatch.est<-array(NA,dim=c(est.time[i]))#
				for(j in 1:est.time[i]){#
						DOY<-32+((time[i]+rv.residence[i])*7+j)#
						grow.est[j]<-growth.rate.est(DOY,1)#
						size.est[j]<-size.out.rv[i]+sum(grow.est[1:j])#
						surv.est[j]<-1-(est.mort(size.est[j]))#
						size.hatch.est[j]<-size.out.rv.hatch[i]+sum(grow.est[1:j])#
						surv.hatch.est[j]<-1-(est.mort(size.hatch.est[j]))						#
						}#
					est.surv[i]<-prod(surv.est)#
					est.surv.hatch[i]<-prod(surv.hatch.est)#
					size.out.est[i]<-tail(size.est,1)#
					size.out.est.hatch[i]<-tail(size.hatch.est,1)#
								}		#
			early.final.fish<-early.total.rv.out*est.surv#
			late.final.fish<-late.total.rv.out*est.surv#
			hatch.final.fish<-hatch.total.rv.out*est.surv.hatch*(hatch.surv.rel.wld)#
			final.fish<-early.final.fish+late.final.fish+hatch.final.fish#
		#------------------------##
		#4. marine survival##
		#------------------------##
			mar.surv.wild<-(mar.surv.func(size.out.est))*2#
			mar.surv.hatch<-(mar.surv.func(size.out.est.hatch))#
			early.recruits<-early.final.fish*mar.surv.wild#
			late.recruits<-late.final.fish*mar.surv.wild#
			hatch.recruits<-hatch.final.fish*mar.surv.hatch#
			recruits<-early.recruits+late.recruits+hatch.recruits#
			spawn<-(sum(early.recruits)*(1-PSM)+sum(late.recruits)*(1-PSM)+sum(hatch.recruits))*0.74#
	PSC.output<-list("recruits"=recruits,"total.rv.out"=total.rv.out,"size.out.est"=size.out.est,"start.fish"=start.fish,"final.fish"=final.fish,"fry.start"=fry.start,"spawn"=spawn) #
	PSC.output#
}
model <- psc.model(0,"baseline",10,"distribution","variable",0,0)
model <- psc.model(0,"baseline",10,"distribution","variable",0,0, 105,0)
## Load functions and libraries for analysis#
source("functions.R") #
#
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)#
library(ggplot2)#
library(gridExtra)#
library(ggpubr)#
library(viridis)
# --- Richness simulations -------------------------------------------------------------#
  # --- Set common conditions for simulations  -------------------------------------------#
  pops <- c(6,9,12,15,18,21,24,27,30,33)#
  max.a <- 7 # maximum productivity#
  min.a <- 2 # minimum productivity#
  steps <- 10 # of steps between high and low heterogenity#
  equ_spw <- 400000 # equilibrium abundance (assumes all pops are the same size)#
  min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
  rho.all <- array(NA,dim=c(steps,1))#
  rho.range <- seq(min_cor,0.99,length.out=steps)#
  for(ww in 1:length(rho.range)){#
    rho.all[ww,] <- rho.range[ww]#
  }#
  ny = 50#
  num.sims <-300#
  phi <- 0.8#
  episd <- 0.6#
  Preturn <- c(0,0,1,0)#
  for.error <- 0.1#
  OU <- 0
# --- Low heterogenity in stock productivity  -----------------------------------------#
  outcomes <- array(NA,dim=c(num.sims,7))#
  mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
  for(ii in 1:length(pops)){#
    for(jj in 1:steps){#
      # biological characteristics#
      pop.num <- pops[ii]#
      inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes","Yes")#
      alpha<- inputs$alphas[2,]#
      beta<- inputs$betas[2,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]#
      control <- 0 #1 is perfect and 0 is none#
      MSY.add <- 1#
      source("MSY_hcr_function.R")		#
      # run simulations!#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  saveRDS(mean_out,"output/richness_sync_300_0.8_0.6_0010_0.1_0_heteroP2.12July2019")
# --- Moderate heterogenity in stock productivity  -----------------------------------------#
  outcomes <- array(NA,dim=c(num.sims,7))#
  mean_out <- array(NA,dim=c(length(pops),steps,7),dimnames=list(pops,seq(min_cor,1,length.out=steps),NULL))#
  for(ii in 1:length(pops)){#
    for(jj in 1:steps){#
      # biological characteristics#
      pop.num <- pops[ii]#
      inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes","Yes")#
      alpha<- inputs$alphas[5,]#
      beta<- inputs$betas[5,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]#
      control <- 0 #1 is perfect and 0 is none#
      MSY.add <- 1#
      source("MSY_hcr_function.R")		#
      # run simulations!#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  saveRDS(mean_out,"output/richness_sync_300_0.8_0.6_0010_0.1_0_heteroP5.12July2019")
# --- Mgmt. lever simulations ------------------------------------------------------------#
  # --- Set common conditions for simulations  ------------------------------------------#
  pops <- 12 # of populations (MUST BE EVEN)#
  max.a <- 7 # maximum productivity#
  min.a <- 2 # minimum productivity#
  steps <- 10 # of steps between high and low heterogenity#
  equ_spw <- 40000 # equilibrium abundance (assumes all pops are the same size)#
  min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
  inputs <- hetero_prod_func(pops, max.a, min.a, steps, equ_spw,"No","Yes") # generate matrix of alphas and betas#
  rho.all <- array(NA,dim=c(steps,1))#
  rho.range <- seq(min_cor,0.99,length.out=steps)#
  for(ww in 1:length(rho.range)){ # range of covariation among populaitons#
    rho.all[ww,] <- rho.range[ww]#
  }#
  ny = 50#
  num.sims <- 200#
  phi <- 0.8#
  episd <- 0.6#
  Preturn <- c(0,0,1,0)#
  for.error <- 0.1#
#
  outcomes <- array(NA,dim=c(num.sims,7))#
  mean_out <- array(NA,dim=c(steps,steps,7),dimnames=list(seq(0,1,length.out=steps),seq(min_cor,1,length.out=steps),NULL))#
  # --- Simulations: mgmt. control = 0, risk tol. = 1 ------------------------------------#
  control <- 0 #
  MSY.add <- 1#
    for(ii in 1:steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]		#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- sims_out#
  # --- Simulations: mgmt. control = 1, risk tol. = 1 ------------------------------------#
  control <- 1 #
  MSY.add <- 1#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.125, risk tol. = 1 ---------------------------------#
  control <- 0.125 #
  MSY.add <- 1#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.25, risk tol. = 1 ------------------------------------#
  control <- 0.25 #
  MSY.add <- 1#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.375, risk tol. = 1 ------------------------------------#
  control <- 0.375 #
  MSY.add <- 1#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.5, risk tol. = 1 ------------------------------------#
  control <- 0.5 #
  MSY.add <- 1#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]		#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.75, risk tol. = 1 ------------------------------------#
  control <- 0.75 #
  MSY.add <- 1#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]		#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0, risk tol. = 0.75 ------------------------------------#
  control <- 0 #
  MSY.add <- 0.75#
    for(ii in 1:steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]		#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 1, risk tol. = 0.75 ------------------------------------#
  control <- 1 #
  MSY.add <- 0.75#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.125, risk tol. = 0.75 ------------------------------------#
  control <- 0.125 #
  MSY.add <- 0.75#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.25, risk tol. = 0.75 ------------------------------------#
  control <- 0.25 #
  MSY.add <- 0.75#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.375, risk tol. = 0.75 ------------------------------------#
  control <- 0.375 #
  MSY.add <- 0.75#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.5, risk tol. = 0.75 ------------------------------------#
  control <- 0.5 #
  MSY.add <- 0.75#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]		#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.75, risk tol. = 0.75 ------------------------------------#
  control <- 0.75 #
  MSY.add <- 0.75#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]		#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0, risk tol. = 0.5 ------------------------------------#
  control <- 0 #
  MSY.add <- 0.5#
    for(ii in 1:steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]		#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 1, risk tol. = 0.5 ------------------------------------#
  control <- 1 #
  MSY.add <- 0.5#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.125, risk tol. = 0.5 ------------------------------------#
  control <- 0.125 #
  MSY.add <- 0.5#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.25, risk tol. = 0.5 ------------------------------------#
  control <- 0.25 #
  MSY.add <- 0.5#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.375, risk tol. = 0.5 ------------------------------------#
  control <- 0.375 #
  MSY.add <- 0.5#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.5, risk tol. = 0.5 ------------------------------------#
  control <- 0.5 #
  MSY.add <- 0.5#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]		#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0.75, risk tol. = 0.5 ------------------------------------#
  control <- 0.75 #
  MSY.add <- 0.5#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]		#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0, risk tol. = 0.25 ------------------------------------#
  control <- 0 #
  MSY.add <- 0.25#
    for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0, risk tol. = 0.875 ------------------------------------#
  control <- 0#
  MSY.add <- 0.875#
  for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0, risk tol. = 0.35 ------------------------------------#
  control <- 0#
  MSY.add <- 0.35#
  for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0, risk tol. = 0.3 ------------------------------------#
  control <- 0#
  MSY.add <- 0.3#
  for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Simulations: mgmt. control = 0, risk tol. = 0.1 ------------------------------------#
  control <- 0#
  MSY.add <- 0.1#
  for(ii in 1: steps){#
    for(jj in 1: steps){#
      alpha<- inputs$alphas[ii,]#
      beta<- inputs$betas[ii,]#
      Ro <- log(alpha)/beta; sum(Ro)#
      rho <- rho.all[jj,]				#
      source("MSY_hcr_function.R")				#
      for (l in 1: num.sims){#
        out <- process(ny, Ro, rho, phi, Preturn, episd, alpha, beta, control, MSY.add, for.error)#
        outcomes[l,] <- out$PMs#
      }#
      mean_out[ii,jj,] <- apply(outcomes,c(2),quantile,probs=c(0.5),na.rm=T)#
    }#
  }#
  sims_out.1 <- melt(mean_out[,,5])#
  sims_out <- cbind(sims_out.1, melt(mean_out[,,6])[,3],rep(control,(steps* steps)),rep(MSY.add,(steps* steps)),melt(mean_out[,,2])[,3])#
  colnames(sims_out)<- c("het_prod","sync","ext","CV_har","control","MSY","harvest")#
  master.sims_out <- rbind(master.sims_out,sims_out)#
  # --- Save all combined simulation output ------------------------------------#
  saveRDS(master.sims_out,"output/mgmt_risk_sims.200.phi_0.8.Rho_0.6.logFE_0.1.OU_0.12July2019")
## Load functions and libraries for analysis#
source("functions.R") #
#
library(MASS)#
library(reshape)#
library(mvtnorm)#
library(gsl)#
library(gdata)#
library(graphics)#
library(fields)#
library(dichromat)#
library(ggplot2)#
library(gridExtra)#
library(ggpubr)#
library(viridis)
# --- Set common conditions for simulations  -------------------------------------------#
  pops <- c(6,9,12,15,18,21,24,27,30,33)#
  max.a <- 7 # maximum productivity#
  min.a <- 2 # minimum productivity#
  steps <- 10 # of steps between high and low heterogenity#
  equ_spw <- 400000 # equilibrium abundance (assumes all pops are the same size)#
  min_cor <- 0 # minimum value of degree of correlation (with 10 pops cannot go lower than ... )#
  rho.all <- array(NA,dim=c(steps,1))#
  rho.range <- seq(min_cor,0.99,length.out=steps)#
  for(ww in 1:length(rho.range)){#
    rho.all[ww,] <- rho.range[ww]#
  }#
  ny = 50#
  num.sims <-300#
  phi <- 0.8#
  episd <- 0.6#
  Preturn <- c(0,0,1,0)#
  for.error <- 0.1#
  OU <- 0
ii<-6
pop.num <- pops[ii]#
      inputs <- hetero_prod_func(pop.num, max.a, min.a, steps, equ_spw,"Yes","Yes")#
      alpha<- inputs$alphas[8,]#
      beta<- inputs$betas[8,]
alpha
pop.num
Ro <- log(alpha)/beta; sum(Ro)
jj<-3
rho <- rho.all[jj,]
control <- 0 #1 is perfect and 0 is none
MSY.add <- 1
source("MSY_hcr_function.R")
master.har
rlnorm(1,0,for.error)
for.error
rlnorm(1,0,for.error)
rlnorm(1,0,for.error)
rlnorm(1,0,for.error)
rlnorm(1,0,for.error)
hist(rlnorm(100,0,for.error))
0.1^2
sqrt(0.1)
sqrt(0.05)
